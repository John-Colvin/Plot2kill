/**This file contains the GTK-specific parts of Plot2Kill and is publicly
 * imported by plot2kill.figure if compiled with -version=gtk.  This is even
 * more a work in progress than the DFL version.
 *
 * BUGS:
 *
 * 1.  Text word wrap doesn't work yet because the gtkD text drawing API is
 *     missing some functionality.
 *
 * 2.  HeatMap is beyond slow.
 *
 *
 * Copyright (C) 2010 David Simcha
 *
 * License:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module plot2kill.gtkwrapper;

version(gtk) {

import plot2kill.util;

import gdk.Color, gdk.GC, gtk.Widget, gdk.Drawable, gtk.DrawingArea,
    gtk.MainWindow, gtk.Main, gdk.Window, gtk.Container, gtk.Window,
    gdk.Pixbuf, gdk.Pixmap, gtkc.all, gtk.FileChooserDialog, gtk.Dialog,
    gtk.FileFilter;

/**GTK's implementation of a color object.*/
class Color : gdk.Color.Color {
    final ubyte r()  {
        int v24 = getValue24();
        return (cast(ubyte*)&v24)[2];
    }

    final ubyte g()  {
        int v24 = getValue24();
        return (cast(ubyte*)&v24)[1];
    }

    final ubyte b()  {
        int v24 = getValue24();
        return (cast(ubyte*)&v24)[0];
    }

    this(ubyte r, ubyte g, ubyte b) {
        super(r, g, b);
    }
}

/**GTK's GC, or GraphicsContext object.*/
alias gdk.GC.GC Pen;

/**Again, GTK's GC, or GraphicsContext object.*/
alias gdk.GC.GC Brush;

///
struct Point {
    ///
    int x;

    ///
    int y;
}

///
struct Rect {
    ///
    int x;

    ///
    int y;

    ///
    int width;

    ///
    int height;
}

///
struct Size {
    ///
    int width;

    ///
    int height;
}

/**GTK's font class.*/
alias gdk.Font.Font Font;

/**Get a color in a GUI framework-agnostic way.*/
Color getColor(ubyte red, ubyte green, ubyte blue) {
    return new Color(red, green, blue);
}

/**Get a font in a GUI framework-agnostic way.*/
Font getFont(string fontName, int size) {
    auto fontNameComplicated =
        text("-*-", fontName, "-*-r-*--", size, "-*-*-*-*-*-*-*");
    auto ret = Font.load(fontNameComplicated);
    return ret;
}


///
enum TextAlignment {
    ///
    Left = 0,

    ///
    Center = 1,

    ///
    Right = 2
}

// This calls the relevant lib's method of cleaning up the given object, if
// any.
void doneWith(T)(T garbage) {
    static if(is(T : gdk.GC.GC) || is(T : gdk.Pixmap.Pixmap) ||
              is(T : gdk.Pixbuf.Pixbuf)) {
        // Most things seem to manage themselves fine, but these objects
        // leak like a seive.
        garbage.unref();

        // Since we're already in here be dragons territory, we may as well:
        core.memory.GC.free(cast(void*) garbage);
    }
}

/**The base class for both FigureBase and Subplot.  Holds common functionality
 * like saving and text drawing.
 */
abstract class PlotDrawingBase : DrawingArea {
    mixin(GuiAgnosticBaseMixin);

protected:
    Drawable drawable;

    Pen textPen;

    ~this() {
        doneWith(textPen);
    }

    void drawTextImpl(
        Drawable localDrawable,
        string text,
        Font font,
        Color pointColor,
        Rect rect,
        TextAlignment alignment
    ) {
        textPen.setForeground(pointColor);

        if(text.length == 0 || font is null) {
            return;
        }

        immutable w = font.textWidth(text, text.length);
        immutable diff = rect.width - w;
        if(diff <= 0) {  // Draw left aligned, do the best we can.
            return drawTextImpl
                (localDrawable, text, font, pointColor, rect);
        }

        immutable newX = (alignment == TextAlignment.Center) ?
                          (diff / 2 + rect.x) :
                          (alignment == TextAlignment.Right) ?
                          (diff + rect.x) :
                           0;
        rect = Rect(newX, rect.y, w, rect.height);
        drawTextImpl(localDrawable, text, font, pointColor, rect);
    }

    void drawTextImpl(
        Drawable localDrawable,
        string text,
        Font font,
        Color pointColor,
        Rect rect
    ) {
        textPen.setForeground(pointColor);

        if(text.length == 0 || font is null) {
            return;
        }
        // GTK uses the baseline as the y coordinate.  We use the vertical
        // orign.  This correction is purely based on trial and error, but
        // looks dead on in practice.  This doesn't, however, mean that
        // it will work in every corner case.
        rect.y += font.textHeight(text, text.length) * 3 / 4;

        localDrawable.drawText(font, textPen, rect.x, rect.y, text, text.length);
    }

public:
    // All this stuff that's public but not documented would be package at least
    // for now if package worked.  If you're a user of this lib and not a
    // developer of it, please be advised that this stuff is in no way stable
    // and could change at any time.  Some of it will eventually be exposed,
    // but I'm not sure how yet.

    final void drawLine(Pen pen, int startX, int startY, int endX, int endY) {
        drawable.drawLine(pen,
            startX + xOffset, startY + yOffset,
            endX + xOffset, endY + yOffset);
    }

    final void drawLine(Pen pen, Point start, Point end) {
        this.drawLine(pen, start.x, start.y, end.x, end.y);
    }

    final void drawRectangle(Pen pen, int x, int y, int width, int height) {
        // The zero means don't fill the rectangle.  To draw filled rectangles
        // in Plot2Kill, we use fillRectangle().
        drawable.drawRectangle(pen, 0, x + xOffset, y + yOffset, width, height);
    }

    final void drawRectangle(Pen pen, Rect r) {
        this.drawRectangle(pen, r.x, r.y, width, height);
    }

    final void fillRectangle(Brush brush, int x, int y, int width, int height) {
        // The one means don't fill the rectangle.  To draw unfilled rectangles
        // in Plot2Kill, we use drawRectangle().
        drawable.drawRectangle(brush, 1, x + xOffset, y + yOffset, width, height);
    }

    final void fillRectangle(Brush brush, Rect r) {
        this.fillRectangle(brush, r.x, r.y, r.width, r.height);
    }

    final void drawText(
        string text,
        Font font,
        Color pointColor,
        Rect rect,
        TextAlignment alignment
    ) {
        auto offsetRect = Rect(rect.x + xOffset, rect.y + yOffset,
            rect.width, rect.height);
        drawTextImpl(
            drawable, text, font, pointColor, offsetRect, alignment);
    }

    final void drawText(
        string text,
        Font font,
        Color pointColor,
        Rect rect
    ) {
        auto offsetRect = Rect(rect.x + xOffset, rect.y + yOffset,
            rect.width, rect.height);
        drawTextImpl(drawable, text, font, pointColor, offsetRect);
    }

    final void drawRotatedText(
        string text,
        Font font,
        Color pointColor,
        Rect rect,
        TextAlignment alignment
    ) {
        // Temporary kludge to prevent text from being cut off.  I have
        // no idea what the root cause of this is, but it seems like
        // the rendering of text gets cut off a few pixels short of
        // the edge of the Drawable and/or the measurements are a
        // few pixels off.
        //
        // TODO:  Remove this quick and dirty fix and put in a proper one.
        version(Posix) {
            rect.x -= 3;
            rect.height += 6;
        }

        auto pixmap = new Pixmap(null, rect.height, rect.width, 24);

        // Make the pixmap's background white.
        textPen.setForeground(getColor(255, 255, 255));
        pixmap.drawRectangle(textPen, 1, 0, 0, rect.height, rect.width);
        scope(exit) doneWith(pixmap);

        auto pixmapRect = Rect(0, 0, rect.height, rect.width);

        // Again this is the anti-text being cut off kludge.
        version(Posix) {
            pixmapRect.y += 3;
            pixmapRect.height -= 3;
        }

        drawTextImpl(pixmap, text, font, pointColor, pixmapRect, alignment);

        auto pixbuf = new Pixbuf(pixmap, 0, 0, rect.height, rect.width);
        scope(exit) doneWith(pixbuf);

        pixbuf = pixbuf.rotateSimple(cast(GdkPixbufRotation) 90);
        pixbuf.renderToDrawable(this.drawable, textPen, 0, 0, rect.x + xOffset,
            rect.y + yOffset, rect.width, rect.height, cast(GdkRgbDither) 0, 0, 0);
    }

    final void drawRotatedText(
        string text,
        Font font,
        Color pointColor,
        Rect rect
    ) {
        drawRotatedText(text, font, pointColor, rect, TextAlignment.Left);
    }


    final Size measureText
    (string text, Font font, int maxWidth, TextAlignment alignment) {
        if(text.length == 0) {
            return Size(0, 0);
        }

        return Size(1, 1);
    }

    // BUGS:  Ignores maxWidth.
    final Size measureText(string text, Font font, int maxWidth) {
        if(text.length == 0) {
            return Size(0, 0);
        }

        return measureText(text, font);

    }

    final Size measureText(string text, Font font) {
        if(text.length == 0) {
            return Size(0, 0);
        }

        return Size(
            font.textWidth(text, text.length),
            font.textHeight(text, text.length)
        );
    }

    // TODO:  Add support for stuff other than solid brushes.
    /*Get a brush in a GUI framework-agnostic way.*/
    final Brush getBrush(Color color) {
        auto ret = new GC(drawable);
        ret.setForeground(color);
        return ret;
    }

    /*Get a pen in a GUI framework-agnostic way.*/
    final Pen getPen(Color color, int width = 1) {
        auto ret = new GC(drawable);
        ret.setForeground(color);
        ret.setLineAttributes(
            width, cast(GdkLineStyle) 0, cast(GdkCapStyle) 0, cast(GdkJoinStyle) 0);
//            GdkLineStyle.GDK_LINE_SOLID,  // Eventually need to expose this.
//            GdkCapStyle.GDK_CAP_BUTT,    // Normal lines.
//            GdkJoinStyle.GDK_JOIN_MITER  // Who cares?
//        );
        return ret;
    }

    final int width()  {
       if(_width > 0) {
           return _width;
       }

       GtkRequisition req;
       this.sizeRequest(req);
       return req.width;
    }

    final int height()  {
       if(_height > 0) {
           return _height;
       }

       GtkRequisition req;
       this.sizeRequest(req);
       return req.height;
    }

    void parentSizeChanged(GtkAllocation* alloc, Widget widget) {
        if(this.width != alloc.width || this.height != alloc.height) {
            this.setSizeRequest(alloc.width, alloc.height);
        }
    }

    abstract void draw() { }

    void drawToRaster(Drawable drawable) {
        drawToRaster(drawable, this.width, this.height);
    }

    // Weird function overloading bugs.  This should be removed.
    void drawToRaster(Drawable drawable, int width, int height) {
        return drawToRaster(drawable, Rect(0, 0, width, height));
    }

    // Allows drawing at an offset from the origin.
    void drawToRaster(Drawable drawable, Rect whereToDraw) {
        // Save the default class-level values, make the values passed in the
        // class-level values, call drawPlot(), then restore the default values.
        auto oldDrawable = this.drawable;
        auto oldWidth = this._width;
        auto oldHeight = this._height;
        auto oldXoffset = this.xOffset;
        auto oldYoffset = this.yOffset;

        scope(exit) {
            this.drawable = oldDrawable;
            this._height = oldHeight;
            this._width = oldWidth;
            this.xOffset = oldXoffset;
            this.yOffset = oldYoffset;
        }

        this.drawable = drawable;
        this._width = whereToDraw.width;
        this._height = whereToDraw.height;
        this.xOffset = whereToDraw.x;
        this.yOffset = whereToDraw.y;
        draw();
    }

    /**Saves this figure to a file.  The file type can be either .png,
     * .jpg, .ico, .tiff, or .bmp.  width and height allow you to specify
     * explicit width and height parameters for the image file.  These will
     * not affect the width and height properties of this object after this
     * method returns.  If width and height are left at their default values
     * of 0, the current object-level width and height properties will be
     * used.
     */
    void saveToFile
    (string filename, string type, int width = 0, int height = 0) {
        if(width <= 0 || height <= 0) {
            width = this.width;
            height = this.height;
        }

        auto pixmap = new Pixmap(null, width, height, 24);
        scope(exit) doneWith(pixmap);

        drawToRaster(pixmap, width, height);
        auto pixbuf = new Pixbuf(pixmap, 0, 0, width, height);
        scope(exit) doneWith(pixbuf);

        pixbuf.savev(filename, type, null, null);
    }

    /**Draw and display the figure as a main form.  This is useful in
     * otherwise console-based apps that want to display a few plots.
     * However, you can't have another main form up at the same time.
     */
    void showAsMain() {
        auto mw = new DefaultPlotWindow!(MainWindow)(this);
        Main.run();
    }

    /**Returns a default plot window with this figure in it.*/
    gtk.Window.Window getDefaultWindow() {
        return new DefaultPlotWindow!(gtk.Window.Window)(this);
    }
}



/**The GTK-specific parts of the Figure class.  These include wrappers around
 * the subset of drawing functionality used by Plot2Kill.
 *
 * In the GTK version of this lib, the Figure class can be used in two ways.
 * It can be used as a Widget and in this case will implicitly draw on itself,
 * or it can draw its plots to an arbitrary Drawable.  For now, a limitation
 * of this is that the arbitrary drawable must have the same depth as this
 * object's default Drawable, which is 24 bits.
 */
class FigureBase : PlotDrawingBase {
private:
    // Fudge factors for the space that window borders take up.  TODO:
    // Figure out how to get the actual numbers and use them instead of these
    // stupid fudge factors.
    enum verticalBorderSize = 0;
    enum horizontalBorderSize = 0;

    bool onDrawingExpose(GdkEventExpose* event, Widget drawingArea) {
        drawPlot();
        return true;
    }

protected:
    this() {
        super();
        this.addOnExpose(&onDrawingExpose);
        this.setSizeRequest(800, 600);  // Default size.
    }


public:
// Begin "real" public API.

    override void draw() {
        drawPlot();
    }

    /**Draw the plot to the internal drawable.*/
    abstract void drawPlot() {
        if(this.drawable is null) {
            enforce(getParent() !is null);
            this.realize();
            this.drawable = getWindow();
        }

        if(textPen is null) {
            textPen = new GC(drawable);
        }
    }

    final void doneDrawing() {}
}

/**Default plot window.  It's a subclass of either Window or MainWindow
 * depending on the template parameter.
 */
template DefaultPlotWindow(Base)
if(is(Base == gtk.Window.Window) || is(Base == gtk.MainWindow.MainWindow)) {

    ///
    class DefaultPlotWindow : Base {
    private:
        PlotDrawingBase fig;

        immutable string[4] saveTypes =
            ["*.png", "*.bmp", "*.tiff", "*.jpeg"];

        // Based on using print statements to figure it out.  If anyone can
        // find the right documentation and wants to convert this to a proper
        // enum, feel free.
        enum rightClick = 3;


        void saveDialogResponse(int response, Dialog d) {
            auto fc = cast(FileChooserDialog) d;
            assert(fc);

            if(response == GtkResponseType.GTK_RESPONSE_OK) {
                string name = fc.getFilename();
                auto fileType = fc.getFilter().getName();

                fig.saveToFile(name, fileType);
                d.destroy();
            } else {
                d.destroy();
            }
        }


        bool clickEvent(GdkEventButton* event, Widget widget) {
            if(event.button != rightClick) {
                return false;
            }


            auto fc = new FileChooserDialog("Save plot...", this,
               GtkFileChooserAction.SAVE);
            fc.setDoOverwriteConfirmation(1);  // Why isn't this the default?
            fc.addOnResponse(&saveDialogResponse);

            foreach(ext; saveTypes) {
                auto filter = new FileFilter();
                filter.setName(ext[2..$]);
                filter.addPattern(ext);
                fc.addFilter(filter);
            }

            fc.run();
            return true;
        }

    public:
        ///
        this(PlotDrawingBase fig) {
            super("Plot Window.  Right-click to save plot.");
            this.fig = fig;
            this.resize(fig.width, fig.height);
            this.setUsize(400, 300);

            this.add(fig);
            this.addOnButtonPress(&clickEvent);
            fig.addOnSizeAllocate(&fig.parentSizeChanged);
            fig.showAll();
            fig.queueDraw();
            this.showAll();
        }
    }
}

}
