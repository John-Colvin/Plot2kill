/**This file contains all of the plot types and Figure, which is a container
 * that draws one or more Plots onto a drawable surface.
 *
 * Copyright (C) 2010-2011 David Simcha
 *
 * License:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module plot2kill.figure;

import plot2kill.util, std.typetuple, std.random;

version(dfl) {
    public import plot2kill.dflwrapper;
} else version(gtk) {
    public import plot2kill.gtkwrapper;
}

package enum legendSymbolSize = 15;  // 30 by 30 pixels.
private enum legendSymbolTextSpace = 3;

/**A container form for one or more Plot objects.
 *
 * Examples:
 * ---
 * auto nums = [1,1,1,1,2,2,3,3,4,5,6,7];
 * auto hist = Histogram(nums, 10);
 * auto fig = new Figure;
 * fig.addPllot(hist);
 * fig.title = "A plot";
 * fig.xLabel = "X label";
 * fig.yLabel = "Y label";
 * fig.showAsMain();
 * ---
 */
class Figure : FigureBase {
private:
    double upperLim = -double.infinity;
    double lowerLim = double.infinity;
    double leftLim = double.infinity;
    double rightLim = -double.infinity;

    double[] xAxisLocations;
    string[] xAxisText;

    double[] yAxisLocations;
    string[] yAxisText;

    // These control whether to auto set the axes.
    bool userSetXAxis = false;
    bool userSetYAxis = false;

    bool _horizontalGrid;
    bool _verticalGrid;

    bool _rotatedXTick;
    bool _rotatedYTick;

    double topMargin = 10;
    double bottomMargin = 10;
    double leftMargin = 10;
    double rightMargin = 30;

    enum tickPixels = 10;
    enum legendMarginHoriz = 20;
    enum legendMarginVert = 10;
    double xTickLabelWidth;
    double yTickLabelWidth;
    double tickLabelHeight;

    Pen axesPen;
    Pen gridPen;

    Font _axesFont;
    Font _legendFont;

    LegendLocation _legendLoc = LegendLocation.bottom;

    void fixTickSizes() {
        void fixTickLabelSize(ref double toFix, string[] axisText) {
            toFix = 0;
            foreach(lbl; axisText) {
                auto lblSize = measureText(lbl, _axesFont);
                if(lblSize.height > tickLabelHeight) {
                    tickLabelHeight = lblSize.height;
                }

                if(lblSize.width > toFix) {
                    toFix = lblSize.width;
                }
            }
        }

        tickLabelHeight = 0;
        fixTickLabelSize(xTickLabelWidth, xAxisText);
        fixTickLabelSize(yTickLabelWidth, yAxisText);
    }

    void fixMargins() {
        fixTickSizes();
        immutable legendMeasure = measureLegend();
        immutable legendHeight = legendMeasure.height;
        immutable legendWidth = legendMeasure.width;

        immutable xLabelSize = measureText(xLabel(), xLabelFont());
        immutable bottomTickHeight = (rotatedXTick()) ?
            xTickLabelWidth : tickLabelHeight;
        immutable leftTickWidth = (rotatedYTick()) ?
            tickLabelHeight : yTickLabelWidth;

        bottomMargin = bottomTickHeight + tickPixels + xLabelSize.height
            + (legendLocation() == LegendLocation.bottom) * legendHeight + 20;

        topMargin = measureText(title(), titleFont(), plotWidth).height
            + (legendLocation() == LegendLocation.top) * legendHeight + 20;

        leftMargin = measureText(yLabel(), yLabelFont()).height +
             tickPixels + leftTickWidth
             + (legendLocation() == LegendLocation.left) * legendWidth + 30;

        rightMargin = (legendLocation() == LegendLocation.right)
            * legendWidth + 30;
    }

    Tuple!(double, "height", double, "width", int, "nRows") measureLegend() {
        immutable alwaysWrap = legendLocation() == LegendLocation.right ||
            legendLocation() == LegendLocation.left;

        PlotSize ret = PlotSize(0, 0);

        double maxHeight = 0;
        double maxWidth = 0;
        int nRows = 1;
        double rowPos = legendMarginHoriz;

        foreach(plot; plotData) {
            auto itemSize = plot.measureLegend(legendFont(), this);
            maxHeight = max(maxHeight, itemSize.height);
            maxWidth = max(maxWidth, itemSize.width);

            if(alwaysWrap ||
            (itemSize.width + rowPos >= this.width - legendMarginHoriz
            && rowPos > legendMarginHoriz)) {
                nRows++;
                rowPos = itemSize.width + legendMarginHoriz;
            }

            rowPos += itemSize.width + legendMarginHoriz;
        }

        return typeof(return)(
            (maxHeight + legendMarginVert) * nRows,
            maxWidth + legendMarginHoriz,
            nRows
        );
    }

    FigureLine[] extraLines;

    final double plotWidth()  {
        return this.width - leftMargin - rightMargin;
    }

    final double plotHeight()  {
        return this.height - topMargin - bottomMargin;
    }

    mixin(toPixels);

    void drawTitle() {
        if(nullOrInit(titleFont())) {
            return;
        }

        auto height = measureText(title(), titleFont()).height;
        auto rect = PlotRect(leftMargin,
            10, this.plotWidth, height);
        auto format = TextAlignment.Center;
        drawText(title(), titleFont(), getColor(0, 0, 0), rect, format);
    }

    void drawXlabel() {
        if(nullOrInit(xLabelFont())) {
            return;
        }

        immutable textSize = measureText(xLabel(), xLabelFont());
        immutable yTop = this.height - textSize.height - 10
            - (legendLocation() == LegendLocation.bottom) *
                measureLegend().height;
        auto rect = PlotRect(leftMargin, yTop,
            this.width - leftMargin - rightMargin, textSize.height);

        auto format = TextAlignment.Center;
        drawText(xLabel(), xLabelFont(), getColor(0, 0, 0), rect, format);
    }

    void drawYlabel() {
        if(nullOrInit(yLabelFont()) || yLabel().length == 0) {
            return;
        }

        immutable textSize = measureText(yLabel(), yLabelFont());
        immutable margin = (plotHeight - textSize.width) / 2 + topMargin;
        immutable xCoord = 10 + measureLegend().width
            * (legendLocation() == LegendLocation.left);

        auto rect = PlotRect(xCoord, margin, textSize.height, textSize.width);

        drawRotatedText(yLabel(),
            yLabelFont(), getColor(0, 0, 0), rect, TextAlignment.Center);
    }

    void drawExtraLines() {
        foreach(line; extraLines) {
            auto pen = getPen(line.lineColor, line.lineWidth);
            scope(exit) doneWith(pen);

            auto start = PlotPoint(toPixelsX(line.x1), toPixelsY(line.y1));
            auto end = PlotPoint(toPixelsX(line.x2), toPixelsY(line.y2));
            drawClippedLine(pen, start, end);
        }
    }

    void drawAxes() {
        immutable origin = PlotPoint(toPixelsX(leftLim), toPixelsY(lowerLim));
        immutable topLeft = PlotPoint(origin.x, toPixelsY(upperLim));
        immutable bottomRight = PlotPoint(toPixelsX(rightLim), origin.y);

        drawLine(axesPen, origin, topLeft);
        drawLine(axesPen, origin, bottomRight);
    }

    void drawTicks() {
        foreach(i, tickPoint; xAxisLocations) {
            drawXTick(tickPoint, xAxisText[i]);
        }

        foreach(i, tickPoint; yAxisLocations) {
            drawYTick(tickPoint, yAxisText[i]);
        }
    }

    void drawLegend() {
        immutable loc = legendLocation();
        if(loc == LegendLocation.top || loc == LegendLocation.bottom) {
            drawLegendImplTopBottom();
        } else {
            drawLegendImplLeftRight();
        }
    }

    void drawLegendImplTopBottom() {
        immutable measurements = measureLegend();
        if(measurements.height == 0) return;  // No legend.
        immutable rowHeight = measurements.height / measurements.nRows;

        // This needs to be precomputed for centering purposes.
        double[] rowStarts;

        double curX = legendMarginHoriz;

        immutable loc = legendLocation();
        double curY;
        if(loc == LegendLocation.bottom) {
            curY = this.height - measurements.height - 10;
        } else {
            assert(loc == LegendLocation.top);
            curY = measureText(title(), titleFont()).height + 10;
        }

        size_t rowStartIndex = 0;

        foreach(plot; plotData) {
            if(!plot.legendText.length) continue;
            immutable itemSize = plot.measureLegend(legendFont(), this);

            if(itemSize.width + curX >= this.width - legendMarginHoriz
            && curX > legendMarginHoriz) {
                // Find centering.
                auto rowSize = curX - legendMarginHoriz;
                rowStarts ~= max(0, (this.width - rowSize) / 2);
                curX = legendMarginHoriz;
            }

            curX += itemSize.width + legendMarginHoriz;
        }
        // Append last row.
        auto rowSize = curX - legendMarginHoriz;
        rowStarts ~= max(0, (this.width - rowSize) / 2);

        curX = rowStarts[rowStartIndex];
        double nextX;

        foreach(plot; plotData) {
            if(!plot.legendText.length) continue;

            immutable itemSize = plot.measureLegend(legendFont(), this);
            if(itemSize.width + curX >= this.width - legendMarginHoriz
            && curX > legendMarginHoriz) {
                curY += rowHeight;
                rowStartIndex++;
                curX = rowStarts[rowStartIndex];
                nextX = curX;
            }

            drawLegendElem(curX, curY, plot, rowHeight);
            curX += itemSize.width + legendMarginHoriz;
        }
    }

    void drawLegendImplLeftRight() {
        int nRows;
        foreach(plot; plotData) {
            if(plot.legendText().length) nRows++;
        }

        immutable measurements = measureLegend();
        immutable rowHeight = (measurements.height / measurements.nRows);

        double curY = this.height / 2 - nRows * rowHeight / 2;
        immutable loc = legendLocation();
        immutable x = (loc == LegendLocation.left) ? 10 :
            (this.width - measurements.width - 10);

        foreach(plot; plotData) if(plot.legendText().length) {
            drawLegendElem(x, curY, plot, rowHeight);
            curY += rowHeight;
        }
    }

    void drawLegendElem(double curX, double curY, Plot plot, double rowHeight) {
        immutable textSize = measureText(plot.legendText(), legendFont());
        assert(textSize.height <= rowHeight);

        immutable smallLetterHeight = measureText("e", legendFont()).height;
        immutable textX = curX + legendSymbolSize + legendSymbolTextSpace;
        immutable textDiff = (rowHeight - textSize.height);
        auto textRect = PlotRect(textX, curY + textDiff,
            textSize.width,
            textSize.height
        );
        drawText(plot.legendText(), legendFont(), getColor(0, 0, 0), textRect,
            TextAlignment.Left);

        auto ySlack = (smallLetterHeight - legendSymbolSize) / 2;
        auto where = PlotRect(
            curX, curY + rowHeight - ySlack - legendSymbolSize,
            legendSymbolSize, legendSymbolSize
        );
        plot.drawLegendSymbol(this, where);
    }

    // Controls the space between a tick line and the tick label.
    enum lineLabelSpace = 2;

    void drawXTick(double where, string text) {
        immutable wherePixels = toPixelsX(where);
        drawLine(
            axesPen,
            PlotPoint(wherePixels, this.height - bottomMargin),
            PlotPoint(wherePixels, this.height - bottomMargin + tickPixels)
        );

        if(verticalGrid()) {
            drawLine(gridPen,
                PlotPoint(wherePixels, topMargin),
                PlotPoint(wherePixels, this.height - bottomMargin));
        }

        if(nullOrInit(_axesFont)) {
            return;
        }

        auto format = TextAlignment.Center;

        immutable textSize = measureText(text, _axesFont, format);
        immutable tickTextStart =
            this.height - bottomMargin  + tickPixels + lineLabelSpace;

        if(rotatedXTick()) {
            auto rect = PlotRect(wherePixels - tickLabelHeight / 2,
                tickTextStart + tickPixels / 2,
                textSize.height,
                textSize.width
            );

            drawRotatedText(text, _axesFont, getColor(0, 0, 0), rect, format);
        } else {
            auto rect = PlotRect(wherePixels - textSize.width / 2,
                tickTextStart,
                textSize.width,
                textSize.height
            );

            drawText(text, _axesFont, getColor(0, 0, 0), rect, format);
        }
    }

    void drawYTick(double where, string text) {
        immutable wherePixels = this.height - toPixelsY(where);
        drawLine(
            axesPen,
            PlotPoint(leftMargin, this.height - wherePixels),
            PlotPoint(leftMargin - tickPixels, this.height - wherePixels)
        );

        if(nullOrInit(_axesFont)) {
            return;
        }

        if(horizontalGrid()) {
            drawLine(
                gridPen,
                PlotPoint(leftMargin, this.height - wherePixels),
                PlotPoint(this.width - rightMargin, this.height - wherePixels));
        }

        auto format = TextAlignment.Right;

        immutable textSize = measureText(text, _axesFont, format);
        if(rotatedYTick()) {
            auto rect = PlotRect(
                leftMargin - textSize.height - tickPixels - lineLabelSpace,
                this.height - wherePixels - textSize.width / 2,
                textSize.height,
                textSize.width
            );

            drawRotatedText(text, _axesFont, getColor(0, 0, 0), rect, format);
        } else {
            auto rect = PlotRect(
                leftMargin - textSize.width - tickPixels - lineLabelSpace,
                this.height - wherePixels - textSize.height / 2,
                textSize.width,
                textSize.height
            );

            drawText(text, _axesFont, getColor(0, 0, 0), rect, format);
        }
    }

    // Used in setupAxes() via delegate.
    double marginSizeX() {
        return leftMargin;
    }

    // Used in setupAxes() via delegate.
    double marginSizeY() {
        return topMargin + bottomMargin;
    }

    void setupAxes(
        double lower,
        double upper,
        ref double[] axisLocations,
        ref string[] axisText,
        double axisSize,
        ref double labelSize,
        double delegate() marginSize
    )
    in {
        assert(upper > lower, std.conv.text(lower, '\t', upper));
    } body {

        immutable diff = upper - lower;

        double tickWidth = 10.0 ^^ floor(log10(diff));
        if(diff / tickWidth < 2) {
            tickWidth /= 10;
        }

        if(diff / tickWidth > 9) {
            tickWidth *= 2;
        }


        if(diff / tickWidth < 4) {
            tickWidth /= 2;
        }

        double startPoint = ceil(lower / tickWidth) * tickWidth;
        do {
            // The tickWidth * 0.01 is a fudge factor to make the last tick
            // get drawn in the presence of rounding error.
            axisLocations = array(
                iota(startPoint, upper + tickWidth * 0.01, tickWidth)
            );

            axisText = doublesToStrings(axisLocations);
            fixMargins();

            // Prevent labels from running together on small plots.
            if((axisSize - marginSize()) / axisLocations.length < labelSize * 4
               && diff / tickWidth > 2) {
                tickWidth *= 2;
                startPoint = ceil(lower / tickWidth) * tickWidth;
                continue;
            } else {
                break;
            }
        } while(true);
    }

    void setLim(
        double lower,
        double upper,
        ref double oldLower,
        ref double oldUpper,
    ) {
        enforce(upper > lower, "Can't have upper limit < lower limit.");
        oldLower = lower;
        oldUpper = upper;
    }

    void nullFontsToDefaults() {
        if(nullOrInit(titleFont())) {
            _titleFont = getFont(plot2kill.util.defaultFont, 14 + fontSizeAdjust);
        }
        if(nullOrInit(xLabelFont())) {
            _xLabelFont = getFont(plot2kill.util.defaultFont, 14 + fontSizeAdjust);
        }

        if(nullOrInit(yLabelFont())) {
            _yLabelFont = getFont
                (plot2kill.util.defaultFont, 14 + fontSizeAdjust);
        }

        if(nullOrInit(axesFont())) {
            _axesFont = getFont(plot2kill.util.defaultFont, 12 + fontSizeAdjust);
        }

        if(nullOrInit(legendFont())) {
            _legendFont = getFont(plot2kill.util.defaultFont, 12 + fontSizeAdjust);
        }
    }

    static bool isValidPlot(Plot plot) {
        if(plot is null) {
            return false;
        }

        return plot.leftMost <= plot.rightMost &&
            plot.bottomMost <= plot.topMost;
    }
protected:

    this() {}

    this(Plot[] plots...) {
        this();
        addPlot!(Figure)(plots);
    }

package:
    Plot[] plotData;

public:

    override int defaultWindowWidth() {
        return 800;
    }

    override int defaultWindowHeight() {
        return 600;
    }

    override int minWindowWidth() {
        return 400;
    }

    override int minWindowHeight() {
        return 300;
    }

    // These drawing commands aren't documented for now b/c they're subject
    // to change.

    // Returns whether any part of the rectangle is on screen.
    bool clipRectangle(ref double x, ref double y, ref double width, ref double height) {
        // Do clipping.
        auto bottom = y + height;
        auto right = x + width;
        if(x < leftMargin) {
            x = leftMargin;
        }
        if(right > this.width - rightMargin) {
            right = this.width - rightMargin;
        }

        if(y < topMargin) {
            y = topMargin;
        }

        if(bottom > this.height - bottomMargin) {
            bottom = this.height - bottomMargin;
        }

        width = right - x;
        height = bottom - y;
        return width > 0 && height > 0;
    }

    // Convenience
    static bool between(T, U, V)(T num, U lower, V upper) {
        return lower <= num && num <= upper;
    }

    bool clipLine(ref double x1, ref double y1, ref double x2, ref double y2) {
        immutable topPixel = topMargin;
        immutable bottomPixel = this.height - bottomMargin - 1;
        immutable leftPixel = leftMargin + 1;
        immutable rightPixel = this.width - rightMargin;
        if(between(x1, leftPixel, rightPixel) &&
           between(x2, leftPixel, rightPixel) &&
           between(y1, topPixel, bottomPixel) &&
           between(y2, topPixel, bottomPixel)) {

            return true;
        }

        // Handle slope of zero or infinity as a special case.
        if(x1 == x2) {
            if(!between(x1, leftPixel, rightPixel)) {
                return false;
            } else if(y1 < topPixel && y2 < topPixel) {
                return false;
            } else if(y1 > bottomPixel && y2 > bottomPixel) {
                return false;
            }

            y1 = max(y1, topPixel);
            y1 = min(y1, bottomPixel);
            y2 = max(y2, topPixel);
            y2 = min(y2, bottomPixel);
            return true;
        } else if(y1 == y2) {
            if(!between(y1, topPixel, bottomPixel)) {
                return false;
            } else if(x1 < leftPixel && x2 < leftPixel) {
                return false;
            } else if(x1 > rightPixel && x2 > rightPixel) {
                return false;
            }

            x1 = max(x1, leftPixel);
            x1 = min(x1, rightPixel);
            x2 = max(x2, leftPixel);
            x2 = min(x2, rightPixel);
            return true;
        }

        immutable slope = (y2 - y1) / (x2 - x1);
        enum tol = 0;  // Compensate for rounding error.

        void fixX(ref double x, ref double y) {
            if(x < leftPixel) {
                immutable diff = leftPixel - x;
                x = leftPixel;
                y = diff * slope + y;
            } else if(x > rightPixel) {
                immutable diff = rightPixel - x;
                x = rightPixel;
                y = diff * slope + y;
            }
        }

        void fixY(ref double x, ref double y) {
            if(y < topPixel) {
                immutable diff = topPixel - y;
                y = topPixel;
                x = diff / slope + x;
            } else if(y > bottomPixel) {
                immutable diff = bottomPixel - y;
                y = bottomPixel;
                x = diff / slope + x;
            }
        }
        fixX(x1, y1);
        fixX(x2, y2);
        fixY(x1, y1);
        fixY(x2, y2);

        // This prevents weird rounding artifacts where a line appears as a
        // single point on the edge of the figure.
        if(y1 == y2 && x1 == x2 && (
            (y1 == topPixel || y1 == bottomPixel) ||
            (x1 == leftPixel || x1 == rightPixel))) {
            return false;
        }

        // The minuses and pluses are to deal w/ rounding error.
        return between(x1, leftPixel - tol, rightPixel + tol) &&
               between(x2, leftPixel - tol, rightPixel + tol) &&
               between(y1, topPixel - tol, bottomPixel + tol) &&
               between(y2, topPixel - tol, bottomPixel + tol);
    }

    void drawClippedRectangle
    (Pen pen, double x, double y, double width, double height) {
        if(clipRectangle(x, y, width, height)) {
            drawRectangle(pen, x, y, width, height);
        }
    }

    void drawClippedRectangle(Pen pen, PlotRect r) {
        drawClippedRectangle(pen, r.x, r.y, r.width, r.height);
    }

    void fillClippedRectangle
    (Brush brush, double x, double y, double width, double height) {
        if(clipRectangle(x, y, width, height)) {
            fillRectangle(brush, x, y, width, height);
        }
    }

    void fillClippedRectangle(Brush brush, PlotRect rect) {
        fillClippedRectangle(brush, rect.x, rect.y, rect.width, rect.height);
    }

    void drawClippedLine(Pen pen, PlotPoint from, PlotPoint to) {
        auto x1 = from.x;
        auto y1 = from.y;
        auto x2 = to.x;
        auto y2 = to.y;
        immutable shouldDraw = clipLine(x1, y1, x2, y2);

        if(!shouldDraw) {
            return;
        }

        drawLine(pen, PlotPoint(x1, y1), PlotPoint(x2, y2));
    }

    void drawClippedText(string text, Font font,
        Color pointColor, PlotRect rect) {

        // To avoid cutting points off of scatter plots, this function only
        // checks whether the center of each point is on the graph.  Therefore,
        // it may allow points to extend slightly off the graph.  This is
        // annoying, but there's no easy way to fix it w/o risking cutting off
        // points.
        immutable xMid = rect.x + rect.width / 2;
        immutable yMid = rect.y + rect.height / 2;

        if(between(xMid, leftMargin, this.width - rightMargin) &&
           between(yMid, topMargin, this.height - bottomMargin)) {
            drawText(text, font, pointColor, rect);
        }
    }

    ///
    final Font axesFont()() {
        return _axesFont;
    }

    ///
    final This axesFont(this This)(Font newFont) {
        _axesFont = newFont;
        return cast(This) this;
    }

    ///
    final Font legendFont()() {
        return _legendFont;
    }

    ///
    final This legendFont(this This)(Font newFont) {
        _legendFont = newFont;
        return cast(This) this;
    }

    ///
    static Figure opCall() {
        return new Figure;
    }

    /**Convenience factory that adds all plots provided to the Figure.*/
    static Figure opCall(Plot[] plots...) {
        return new Figure(plots);
    }

    /**Manually set the X axis limits.
     */
    final This xLim(this This)(double newLower, double newUpper) {
        setLim(newLower, newUpper, leftLim, rightLim);
        return cast(This) this;
    }

    /**Manually set the Y axis limits.
     */
    This yLim(this This)(double newLower, double newUpper) {
        setLim(newLower, newUpper, lowerLim, upperLim);
        return cast(This) this;
    }

    /**
    Set the zoom back to the default value, i.e. just large enough to fit
    everything on the screen.
    */
    This defaultZoom(this This)() {
        upperLim = -double.infinity;
        lowerLim = double.infinity;
        leftLim = double.infinity;
        rightLim = -double.infinity;

        foreach(plot; plotData) {
            upperLim = max(upperLim, plot.topMost);
            rightLim = max(rightLim, plot.rightMost);
            leftLim = min(leftLim, plot.leftMost);
            lowerLim = min(lowerLim, plot.bottomMost);
        }

        return cast(This) this;
    }

    /**Set the X axis labels.  If text is null (default) the axis text is
     * just the text of the axis locations.  R should be any range with
     * length identical to text (unless text is null) and elements implicitly
     * convertible to double.
     */
    This xTickLabels(R, this This)(R locations, const string[] text = null)
    if(isInputRange!R && is(ElementType!R : double)) {
        userSetXAxis = true;
        xAxisLocations = toDoubleArray(locations);

        if(text.length > 0) {
            enforce(text.length == xAxisLocations.length,
                "Length mismatch between X axis locations and X axis text.");
            xAxisText = text.dup;
        } else {
            xAxisText = doublesToStrings(xAxisLocations);
        }

        return cast(This) this;
    }

    /**Set the Y axis labels.  If text is null (default) the axis text is
     * just the text of the axis locations.  R should be any range with
     * length identical to text (unless text is null) and elements implicitly
     * convertible to double.
     */
    This yTickLabels(R, this This)(R locations, const string[] text = null)
    if(isInputRange!R && is(ElementType!R : double)) {
        userSetYAxis = true;
        yAxisLocations = toDoubleArray(locations);

        if(text.length > 0) {
            enforce(text.length == yAxisLocations.length,
                "Length mismatch between Y axis locations and Y axis text.");
            yAxisText = text.dup;
        } else {
            yAxisText = doublesToStrings(yAxisLocations);
        }

        return cast(This) this;
    }

    /**Determines whether vertical gridlines are drawn.  Default is false.*/
    bool verticalGrid()() {
        return _verticalGrid;
    }

    ///
    This verticalGrid(this This)(bool val) {
        this._verticalGrid = val;
        return cast(This) this;
    }

    /**Determines whether horizontal gridlines are drawn.  Default is false.*/
    bool horizontalGrid()() {
        return _horizontalGrid;
    }

    ///
    This horizontalGrid(this This)(bool val) {
        this._horizontalGrid = val;
        return cast(This) this;
    }

    ///
    LegendLocation legendLocation()() {
        return _legendLoc;
    }

    ///
    This legendLocation(this This)(LegendLocation newLoc) {
        this._legendLoc = newLoc;
        return cast(This) this;
    }

    /**
    Determines whether rotated text is used for the X tick labels.
    */
    final bool rotatedXTick()() {
        return _rotatedXTick;
    }

    /// Setter
    final This rotatedXTick(this This)(bool newVal) {
        _rotatedXTick = newVal;
        return cast(This) this;
    }

    /**
    Determines whether rotated text is used for the Y tick labels.
    */
    final bool rotatedYTick()() {
        return _rotatedYTick;
    }

    /// Setter
    final This rotatedYTick(this This)(bool newVal) {
        _rotatedYTick = newVal;
        return cast(This) this;
    }

    /**The leftmost point on the figure.*/
    double leftMost()  {
        return leftLim;
    }

    /**The rightmost point on the figure.*/
    double rightMost()  {
        return rightLim;
    }

    /**The topmost point on the figure.*/
    double topMost()  {
        return upperLim;
    }

    /**The bottommost point on the figure.*/
    double bottomMost()  {
        return lowerLim;
    }

    /**Add individual lines to the figure.  Coordinates are specified relative
     * to the plot area, not in pixels.  The lines are is clipped
     * to the visible part of the plot area.  This is useful for adding
     * annotation lines, as opposed to plot lines.
     */
    This addLines(this This)(FigureLine[] lines...) {
        extraLines ~= lines;
        return cast(This) this;
    }

    /**Add one or more plots to the figure.*/
    This addPlot(this This)(Plot[] plots...) {
        foreach(plot; plots) {
            if(!isValidPlot(plot)) {
                continue;
            }

            upperLim = max(upperLim, plot.topMost);
            rightLim = max(rightLim, plot.rightMost);
            leftLim = min(leftLim, plot.leftMost);
            lowerLim = min(lowerLim, plot.bottomMost);
            plotData ~= plot;
        }

        return cast(This) this;
    }

    /**Draw the plot but don't display it on screen.*/
    override void drawImpl() {
        auto whiteBrush = getBrush(getColor(255, 255, 255));
        fillRectangle(whiteBrush, 0, 0, this.width, this.height);
        doneWith(whiteBrush);
        // If this is not a valid Figure, leave a big blank white rectangle.
        // It beats crashing.
        if(!(leftLim < rightLim && lowerLim < upperLim)) {
            return;
        }
        axesPen = getPen(getColor(0, 0, 0), 2);
        scope(exit) doneWith(axesPen);

        gridPen = getPen(getColor(0, 0, 0), 1);
        scope(exit) doneWith(gridPen);

        nullFontsToDefaults();

        if(!userSetXAxis) {
            setupAxes(leftLim, rightLim, xAxisLocations, xAxisText,
                this.width, xTickLabelWidth, &marginSizeX);
        }

        if(!userSetYAxis) {
            setupAxes(lowerLim, upperLim, yAxisLocations, yAxisText,
                this.height, tickLabelHeight, &marginSizeY);
        }

        fixMargins();
        drawTicks();

        foreach(plot; plotData) {
            if(!isValidPlot(plot)) {
                continue;
            }

            immutable x = toPixelsX(plot.leftMost);
            immutable y = toPixelsY(plot.topMost);
            immutable subHeight = toPixelsY(plot.bottomMost) - y;
            immutable subWidth = toPixelsX(plot.rightMost) - x;
            plot.drawPlot(this, x, y, subWidth, subHeight);
        }

        drawYlabel();
        drawExtraLines();
        drawAxes();
        drawTitle();
        drawXlabel();
        drawLegend();
    }

    version(none) {
    void showUsingImplicitMain() {
        ImplicitMain.initialize();
        ImplicitMain.addForm(this);
    }
    }
}

///
enum LegendLocation {
    ///
    top,

    ///
    bottom,

    ///
    left,

    ///
    right
}

/**For drawing extra lines on a Figure, with coordinates specified in plot
 * units and relative to the plot area, not in pixels.*/
struct FigureLine {
private:
    double x1;
    double y1;
    double x2;
    double y2;
    Color lineColor;
    uint lineWidth = 1;

public:
    this(double x1, double y1, double x2,
         double y2, Color lineColor, uint lineWidth = 1) {

        enforce(isFinite(x1) && isFinite(x2) && isFinite(y1) && isFinite(y2),
                "Line coordinates must be finite.");
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
        this.lineColor = lineColor;
        this.lineWidth = lineWidth;
    }
}

/**
Most of these classes copy their input data into a double[] by default.  Use
this to signal that copying is unnecessary.  The range primitives just forward
to data.
*/
struct NoCopy {
    ///
    double[] data;

    ///
    double front() @property { return data.front; }

    ///
    void popFront() { data.popFront(); }

    ///
    bool empty() @property { return data.empty; }

    ///
    typeof(this) save() @property { return this; }

    ///
    double opIndex(size_t index) { return data[index]; }

    ///
    typeof(this) opSlice(size_t lower, size_t upper) {
        return NoCopy(data[lower..upper]);
    }
}


/**Abstract base class for all types of plot objects.*/
abstract class Plot {
protected:
    // Top of the plot.
    double upperLim = -double.infinity;

    // Bottom of the plot.
    double lowerLim = double.infinity;

    // Leftmost limit of the plot.
    double leftLim = double.infinity;

    // Rightmost limit of the plot.
    double rightLim = -double.infinity;

    string _legendText;

package:
    PlotSize measureLegend(Font legendFont, FigureBase fig) {
        if(!legendText().length) return PlotSize(0, 0);
        auto ret = fig.measureText(legendText(), legendFont);
        ret.width += legendSymbolSize + legendSymbolTextSpace;
        ret.height = max(ret.height, legendSymbolSize);
        return ret;
    }

public:
    // This should be package but for some reason package functions can't
    // be abstract.
    abstract void drawLegendSymbol(FigureBase fig, PlotRect where);

    /* Draw the plot on Figure using the rectangular area described by the
     * integer parameters.
     */
    abstract void drawPlot(Figure, double, double, double, double);

    /**Convenience method that instantiates a Figure object with this plot.
     * Useful for creating single-plot figures w/o a lot of boilerplate.
     *
     * Examples:
     * ---
     * auto hist = Histogram([1,2,3,4,5], 3).toFigure;
     * hist.showAsMain();
     * ---
     */
    Figure toFigure()  {
        return new Figure(this);
    }

    /**Instantiates a Figure object with this plot and also places the default
     * axes and tick labeling and title for the plot type, if any, on the
     * Figure.  If a plot type has no default labeling, simply forwards to
     * toFigure().
     */
    Figure toLabeledFigure()  {
        return toFigure;
    }

    /**The leftmost point on the plot.*/
    double leftMost()  {
        return leftLim;
    }

    /**The rightmost point on the plot.*/
    double rightMost()  {
        return rightLim;
    }

    /**The topmost point on the plot.*/
    double topMost()  {
        return upperLim;
    }

    /**The bottommost point on the plot.*/
    double bottomMost()  {
        return lowerLim;
    }

    ///
    string legendText()() {
        return _legendText;
    }

    ///
    This legendText(this This)(string newText) {
        _legendText = newText;
        return cast(This) this;
    }
}

/**A basic bar plot.*/
class BarPlot : Plot {
private:
    double[] _centers;
    double[] _heights;
    double[] _lowerErrors;
    double[] _upperErrors;


    void fixBounds() {
        this.leftLim = reduce!min(double.infinity, this.centers) - width / 2;
        this.rightLim = reduce!max(-double.infinity, this.centers) + width / 2;
        lowerLim = double.infinity;
        upperLim = -double.infinity;

        foreach(i, height; _heights) {
            if(lowerErrors.length > 0) {
                lowerLim = min(height - lowerErrors[i], lowerLim);
            } else {
                lowerLim = min(height, lowerLim);
            }

            if(upperErrors.length > 0) {
                upperLim = max(height + upperErrors[i], upperLim);
            } else {
                upperLim = max(height, upperLim);
            }
        }

        // Don't blend error bars into axes.  Handle the case where a boundary
        // is 0 as a special case, since it would look worse to have the axis
        // not be exactly zero if all bars are positive or all are negative than
        // to blend an error bar into an axis.
        if(upperErrors.length || lowerErrors.length) {
            immutable pad = 0.01 * (upperLim - lowerLim);
            if(upperErrors.length && upperLim != 0) {
                upperLim += pad;
            }
            if(lowerErrors.length && lowerLim != 0) {
                lowerLim -= pad;
            }
        }

        if(lowerLim > 0) {
            lowerLim = 0;
        }

        if(upperLim < 0) {
            upperLim = 0;
        }
    }


    this(double[] centers, double[] heights, double width) {
        this._centers = centers;
        this._heights = heights;
        this.width = width;
        _barColor = getColor(0, 0, 255);
        fixBounds();
    }

protected:
    void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {

        mixin(toPixels);
        mixin(drawErrorMixin);

        immutable multiplier = plotHeight / (this.upperLim - this.lowerLim);
        immutable zeroPoint = toPixelsY(0);
        auto brush = form.getBrush(_barColor);
        scope(exit) doneWith(brush);

        auto blackPen = form.getPen(getColor(0, 0, 0));
        scope(exit) doneWith(blackPen);

        foreach(i, center; centers) {
            immutable height = heights[i];
            immutable left = center - width / 2;
            immutable right = center + width / 2;
            immutable leftPixels = toPixelsX(left);
            immutable rightPixels = toPixelsX(right);
            immutable widthPixels = rightPixels - leftPixels;

            immutable heightPixels = roundTo!int(abs(height) * multiplier);

            immutable startAt = (height > 0) ?
                                zeroPoint - heightPixels :
                                zeroPoint;
            form.fillClippedRectangle(brush, leftPixels,
                startAt, widthPixels, heightPixels);
            form.drawClippedRectangle(blackPen, leftPixels,
                startAt, widthPixels, heightPixels);

            // Do error bars.
            if(lowerErrors.length) {
                drawErrorBar(blackPen,
                    center, height, height - lowerErrors[i], width / 2);
            }
            if(upperErrors.length) {
                drawErrorBar(blackPen,
                    center, height, height + upperErrors[i], width / 2);
            }
        }

        if(lowerLim < 0) {
            auto pen = form.getPen(getColor(0, 0, 0), 2);
            // Draw line across figure at the zero point.
            form.drawClippedLine(pen,
                PlotPoint(toPixelsX(leftLim), zeroPoint),
                PlotPoint(toPixelsX(rightLim), zeroPoint)
            );
        }
    }

    override void drawLegendSymbol(FigureBase fig, PlotRect where) {
        drawFillLegend(_barColor, fig, where);
    }

    Color _barColor;

public:
    /**Controls the color of the bar.  Defaults to blue.*/
    final Color barColor()() {
        return _barColor;
    }

    /// Setter
    final This barColor(this This)(Color newColor) {
        _barColor = newColor;
        return cast(This) this;
    }

    ///
    immutable double width;

    /**Create a BarPlot.  centers and heights must be input ranges with elements
     * implicitly convertible to double.  width determines the width of each
     * bar relative to the X-axis scale and must be greater than 0.
     */
    static BarPlot opCall(R1, R2)(R1 centers, R2 heights, double width)
    if(isInputRange!R1 && is(ElementType!R1 : double) &&
       isInputRange!R2 && is(ElementType!R2 : double)) {

        auto c = toDoubleArray(centers);
        auto h = toDoubleArray(heights);

        enforce(c.length == h.length,
            "Centers and heights must be same length for bar plot.");

        enforce(width > 0, "Width must be >0 for bar plot.");
        auto ret = new typeof(return)(c, h, width);
        return ret;
    }

    /**Create a BarPlot with error bars.  lowerErrors and upperErrors
     * must be input ranges with elements implicitly convertible to double for
     * error bars to be shown.  Any other value, such as null or 0, will result
     * in no error bars being shown.  Therefore, to only show, for example,
     * upper erros, simply pass in null or 0 for the lower errors.
     *
     * To draw symmetric error bars, simply pass in the same range for
     * lowerErrors and upperErrors.  However, note that if you do this,
     * the range will need to be a forward range, not an input range.
     */
     static BarPlot opCall(R1, R2, R3, R4)
     (R1 centers, R2 heights, double width, R3 lowerErrors, R4 upperErrors)
     if(isInputRange!R1 && is(ElementType!R1 : double) &&
        isInputRange!R2 && is(ElementType!R2 : double)) {

        auto ret = opCall(centers, heights, width);
        static if(isForwardRange!R3) {
            ret._lowerErrors = toDoubleArray(lowerErrors.save);
        } else static if(isInputRange!R3) {
            ret._lowerErrors = toDoubleArray(lowerErrors);
        }

        static if(isForwardRange!R4) {
            ret._upperErrors = toDoubleArray(upperErrors.save);
        } else static if(isInputRange!R4) {
            ret._upperErrors = toDoubleArray(upperErrors);
        }

        enforce(ret.upperErrors.length == 0 || ret.upperErrors.length ==
            ret.centers.length, "Length of upperErrors must equal number of bars.");
        enforce(ret.lowerErrors.length == 0 || ret.lowerErrors.length ==
            ret.centers.length, "Length of lowerErrors must equal number of bars.");

        ret.fixBounds();
        return ret;
    }

    /**Scale this object by a factor of scaleFactor in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void scaleCenters(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        _centers[] *= scaleFactor;
        fixBounds();
    }

    /**Scale this object by a factor of scaleFactor in the Y direction.
     * This is useful for getting it onto the same scale as another plot.*/
    void scaleHeights(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        _heights[] *= scaleFactor;
        fixBounds();
    }

    /**Shift this graph by shiftBy units in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void shiftCenters(double shiftBy) {
        enforce(isFinite(shiftBy), "Can't shift by infinity or NaN.");
        _centers[] += shiftBy;
        fixBounds();
    }

    /**Get the centers of the bars.*/
    final const(double)[] centers()  {
        return _centers;
    }

    /**Get the heights of the bars.*/
    final const(double)[] heights()  {
        return _heights;
    }

    ///
    final const(double)[] lowerErrors()  {
        return _lowerErrors;
    }

    ///
    final const(double)[] upperErrors()  {
        return _upperErrors;
    }

    /**The default labeling includes each center receiving its own x tick
     * label if there are <= 10 bars on the graph.
     */
    override Figure toLabeledFigure()  {
        auto ret = toFigure;
        if(centers.length <= 10) {
            ret.xTickLabels(centers);
        }

        return ret;
    }
}

private template isRoR(T) {
    enum isRoR = isInputRange!T && isInputRange!(ElementType!T);
}

/**
Create an array of bar plots that, when inserted into a Figure, will effectively
become a grouped bar plot.

Parameters:

centers:
An input range of the overall center of each group of bars.

data:
A range of ranges, with one range for each bar color.  This range should have
one number for each group.

width:
The combined width of all of the bars for each group.

legendText:
An array of strings, one for each bar color, or null if no legend is desired.

colors:
An array of colors, one for each bar.  If none is provided, the default
colors are used.  These are, in order, blue, red, green, black, orange,
and purple.  If more colors are needed, they are generated using a random
number generator with a deterministic seed.

Examples:
---

// Make a plot with three groups:  One for "In Meeting", one for "On Phone",
// and one for "Coding".  The plot will also have two bar colors:  One for
// "Without Caffeine" and one for "With Caffeine".
auto withoutCaffeine = [8, 6, 3];
auto withCaffeine = [5, 3, 1];
auto sleepinessPlot = groupedBar(
    iota(3), [withoutCaffeine, withCaffeine], 0.6,
        ["W/ Caffeine", "W/o Caffeine"],
        [getColor(64, 64, 255), getColor(255, 64, 64)]
);
auto sleepinessFig = Figure(sleepinessPlot)
    .title("Sleepiness Survey")
    .yLabel("Sleepiness Rating")
    .xLabel("Activity")
    .legendLocation(LegendLocation.right)
    .xTickLabels(
        iota(3),
        ["In Meeting", "On Phone", "Coding"]
    );
---
*/
BarPlot[] groupedBar(R1, R2)(
    R1 centers,
    R2 data,
    double width,
    string[] legendText = null,
    Color[] colors = null
)
if(isInputRange!R1 && isRoR!R2) {
     return groupedBar(centers, data, (double[][]).init, (double[][]).init,
        width, legendText, colors);
}

/**
Create a grouped bar plot with error bars.  lowerErrors and upperErrors
must either have the same dimensions as data or be empty.
*/
BarPlot[] groupedBar(R1, R2, R3, R4)(
    R1 centers,
    R2 data,
    R3 lowerErrors,
    R4 upperErrors,
    double width,
    string[] legendText = null,
    Color[] colors = null
)
if(isInputRange!R1 && isRoR!R2 && isRoR!R3 && isRoR!R4) {
    auto centerArr = toDoubleArray(centers);
    auto dataArr = array(map!toDoubleArray(data));
    auto lerrArr = array(map!toDoubleArray(lowerErrors));
    auto uerrArr = array(map!toDoubleArray(upperErrors));

    foreach(elem; TypeTuple!(lerrArr, uerrArr, legendText, colors)) {
        enforce(elem.empty || elem.length == dataArr.length,
            "Range length mismatch in groupedBar.");
    }

    if(!colors.length) {
        colors = [
            getColor(0, 0, 255), getColor(255, 0, 0), getColor(0, 255, 0),
            getColor(0, 0, 0), getColor(255, 128, 0), getColor(255, 0, 255)
        ];

        // If we need more colors, generate them "randomly" but from a
        // deterministic seed.
        auto gen = Random(31415);
        while(colors.length < dataArr.length) {
            colors ~= getColor(
                uniform!"[]"(cast(ubyte) 0, cast(ubyte) 255, gen),
                uniform!"[]"(cast(ubyte) 0, cast(ubyte) 255, gen),
                uniform!"[]"(cast(ubyte) 0, cast(ubyte) 255, gen)
            );
        }
    }

    BarPlot[] ret;
    foreach(int groupIndex, group; dataArr) {
        BarPlot plot;

        enforce(group.length == centerArr.length,
            "Each group's length must be equal to centers.length for "
            ~ "grouped bar plots."
        );
        immutable groupWidth = width / dataArr.length;

        // Shift groupCenters over from overall centers.
        auto groupCenters = centerArr.dup;
        immutable offset = (groupIndex + 0.5) * groupWidth;
        groupCenters[] += offset - width / 2;

        if(lowerErrors.length && upperErrors.length) {
            plot = BarPlot(NoCopy(groupCenters), NoCopy(group), groupWidth,
                NoCopy(lerrArr[groupIndex]), NoCopy(uerrArr[groupIndex])
            );
        } else {
            plot = BarPlot(NoCopy(groupCenters), NoCopy(group), groupWidth);
        }

        plot.barColor(colors[groupIndex]);

        if(legendText.length) {
            plot.legendText(legendText[groupIndex]);
        }

        ret ~= plot;
    }

    return ret;
}

/**Determine behavior for elements outside of a fixed-border histogram's bounds.
 */
enum OutOfBounds {
     /** Throw throws an exception.*/
    Throw,

    /**Ignore simply skips the number.*/
    Ignore
}

/**Controls whether a histogram plots counts or probability.*/
enum HistType {
    /// The Y-axis should be counts.
    Counts,

    /// The Y-axis should be probabilities.
    Probability
}

/**A class for plotting regular (equal-width) histograms.*/
class Histogram : Plot {

    private double binWidth;

    private uint[] binCounts;
    private uint nElem;

    private HistType countsOrProbs;

    private this() {
        _barColor = getColor(0, 0, 255);
    }

    private bool isCumulative = false;

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        uint[] binCounts = this.binCounts;
        if(isCumulative) {
            binCounts = binCounts.dup;
            foreach(i; 1..binCounts.length) {
                binCounts[i] += binCounts[i - 1];
            }
        }

        immutable maxCount = reduce!max(0U, binCounts);
        immutable multiplier = plotHeight / cast(double) maxCount;

        immutable binWidth = cast(double) plotWidth / nBin;
        immutable bottom = plotHeight + topMargin;

        auto blackPen = form.getPen(getColor(0, 0, 0), 1);
        scope(exit) doneWith(blackPen);

        auto brush = form.getBrush(_barColor);
        scope(exit) doneWith(brush);

        double horizPos = leftMargin;
        double lastPosPixels = leftMargin;
        foreach(i, count; binCounts) {
            // Most of the complexity of this loop body is for making the bin
            // boundaries accurate in the context of having to round to
            // pixels.
            immutable barHeight = multiplier * count;
            immutable horizPixels = min(roundTo!int(horizPos), lastPosPixels);
            immutable stopAt = horizPos + binWidth;
            immutable thisBinWidth = max(1.0, stopAt - horizPixels);

            form.fillClippedRectangle(brush, lastPosPixels,
                bottom - barHeight, thisBinWidth, barHeight);
            form.drawClippedRectangle(blackPen, lastPosPixels,
                bottom - barHeight, thisBinWidth, barHeight);
            horizPos += binWidth;
            lastPosPixels = horizPixels + thisBinWidth;
        }
    }

    protected override void drawLegendSymbol(FigureBase fig, PlotRect where) {
        drawFillLegend(_barColor, fig, where);
    }

    private void fixBounds() {
        if(isCumulative) {
            if(countsOrProbs == HistType.Probability) {
                upperLim = 1;
            } else {
                upperLim = nElem;
            }
        } else{
            if(countsOrProbs == HistType.Probability) {
                upperLim = reduce!max(0U, binCounts) / cast(double) nElem;
            } else {
                upperLim = reduce!max(0U, binCounts);
            }
        }
    }

    private OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw;

    private Color _barColor;

    /**Controls the color of the bar.  Defaults to blue.*/
    final Color barColor()() {
        return _barColor;
    }

    /// Setter
    final This barColor(this This)(Color newColor) {
        _barColor = newColor;
        return cast(This) this;
    }


    /// The number of bins this histogram contains.
    final uint nBin() const pure nothrow  {
        return cast(uint) binCounts.length;
    }

    /**Factory method to instantiate this class.  nums must be a forward range
     * with elements implicitly convertible to double.  nBin specifies how many
     * bins the histogram should contain.
     */
    static Histogram opCall(R)(R nums, uint nBin)
    if(isForwardRange!R && is(ElementType!R : double)) {
        double leftLim = double.infinity, rightLim = -double.infinity;
        foreach(num; nums.save) {
            leftLim = min(leftLim, num);
            rightLim = max(rightLim, num);
        }

        return Histogram(nums, nBin, leftLim, rightLim);
    }

    /**Factory method to instantiate this class with predetermined limits.
     * This allows nums to be an input range instead of a forward range, since
     * no pass is necessary to compute the limits.
     *
     * This function both obeys and permanently sets whatever bounds behavior
     * is specified (throwing or ignoring on out of bounds numbers).  The
     * default behavior is to throw.  Rationale:  Errors should only pass
     * silently if explicitly silenced.
     */
    static Histogram opCall(R)(
        R nums,
        uint nBin,
        double leftLim,
        double rightLim,
        OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw
    ) if(isInputRange!R && is(ElementType!R : double)) {
        auto ret = Histogram(nBin, leftLim, rightLim, outOfBoundsBehavior);

        foreach(num; nums) {
            ret.put(num);
        }

        return ret;
    }

    /**Create an empty histogram with pre-specified bounds, which will be
     * filled with data using the put method.
     *
     * Note:  The only reason this is a template is because of bugs in
     * overloading non-templated functions agsinst templated functions.
     */
    static Histogram opCall(I)(
        I nBin,
        double leftLim,
        double rightLim,
        OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw
    ) if(isIntegral!I) {
        auto ret = new Histogram;
        ret.outOfBoundsBehavior = outOfBoundsBehavior;

        enforce(rightLim > leftLim,
            "Cannot create a histogram w/ upper lim <= lower lim.");
        enforce(nBin > 1, "Cannot create a histogram w/ <2 bins.");

        immutable binWidth = (rightLim - leftLim) / nBin;
        ret.binWidth = binWidth;

        ret.leftLim = leftLim;
        ret.rightLim = rightLim;
        ret.binCounts.length = to!uint(nBin);
        ret.lowerLim = 0;
        ret.upperLim = 0;

        return ret;
    }

    /**Add a number to the histogram on the fly.*/
    This put(this This)(double num) {
        if(outOfBoundsBehavior == OutOfBounds.Throw) {
            enforce(num >= leftLim && num <= rightLim, text(
                "Number out of bounds for histogram.  Got:  ", num,
                ", expected between ", leftLim, " and ", rightLim, "."));
        } else {
            if(!(num >= leftLim && num <= rightLim)) {
                return cast(This) this;
            }
        }

        uint bin;
        bin = to!uint((num - leftLim) / binWidth);
        if(bin == nBin) {  // Edge case.
            bin--;
        }

        binCounts[bin]++;
        nElem++;

        if(countsOrProbs == HistType.Counts) {
            if(isCumulative) {
                upperLim = nElem;
            } else if(binCounts[bin] > upperLim) {
                upperLim = binCounts[bin];
            }
        } else if(!isCumulative) {
            immutable binProb = binCounts[bin] / cast(double) nElem;
            if(binProb > upperLim) {
                upperLim = binProb;
            }
        }

        return cast(This) this;
    }

    /**Add the contents of another Histogram to this one.  The boundaries and
     * numbers of bins must be the same.  This histogram's settings are
     * retained.
     */
    This put(this This)(const Histogram rhs) {
        if(rhs is null) {
            return cast(This) this;
        }

        enforce(rhs.leftLim == this.leftLim && rhs.rightLim == this.rightLim,
            "Boundaries must be the same to combine histograms.");
        binCounts[] += rhs.binCounts[];
        nElem += rhs.nElem;

        fixBounds();
        return cast(This) this;
    }

    /**Assumes the LineGraph input is a plot of a PDF that this histogram is
     * supposed to approximate, and scales the Y axis of the LineGraph
     * accordingly so that both appear on the same scale.
     *
     * If this Histogram is cumulative, assumes that the input LineGraph is
     * a CDF instead.
     */
    This scaleDistributionFunction(this This)(LineGraph g) {
        if(isCumulative) {
            if(countsOrProbs == HistType.Counts) {
                g.scaleY(nElem);
            }
        // Don't need to do anything if this is a probability histogram.
        } else {
            double scaleFactor = (rightLim - leftLim) / nBin;
            if(countsOrProbs == HistType.Counts) {
                scaleFactor *= nElem;
            }

            g.scaleY(scaleFactor);
        }

        return cast(This) this;
    }

    /**Determine whether this object throws or ignores if it receives a number
     * outside its bounds via put.
     */
    This boundsBehavior(this This)(OutOfBounds behavior)  {
        outOfBoundsBehavior = behavior;
        return cast(This) this;
    }

    /**Set whether this histogram displays counts or probabilities.*/
    This histType(this This)(HistType newType) {
        countsOrProbs = newType;
        fixBounds();
        return cast(This) this;
    }

    /**Determines whether this histogram is cumulative.*/
    This cumulative(this This)(bool newVal) {
        isCumulative = newVal;
        fixBounds();
        return cast(This) this;
    }
}

/**Creates a histogram with equal frequency binning instead of equal width
 * binning.  The scale of a FrequencyHistogram is the probability density scale.
 *
 * Note that equal frequency binning doesn't work with discrete
 * distributions where probability density may be infinite at a point.
 * Therefore, if a probability density is calculated to be infinite, this
 * class will throw.
 *
 *
 */
class FrequencyHistogram : Plot {
    private double[] binWidths;
    private double elemsPerBin;

    private Color _barColor;

    this() {
        _barColor = getColor(0, 0, 255);
    }

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {

        mixin(toPixels);

        immutable multiplier = plotHeight / (this.upperLim - this.lowerLim);
        immutable zeroPoint = toPixelsY(0);
        auto brush = form.getBrush(_barColor);
        scope(exit) doneWith(brush);
        auto pen = form.getPen(_barColor, 1);
        scope(exit) doneWith(pen);

        auto blackPen = form.getPen(getColor(0, 0, 0));
        scope(exit) doneWith(blackPen);

        double xStart = leftLim;
        immutable totalWidth = rightLim - leftLim;
        foreach(width; binWidths) {
            scope(exit) xStart += width;
            immutable height = totalWidth / width / elemsPerBin;
            immutable leftPixels = toPixelsX(xStart);
            immutable rightPixels = toPixelsX(xStart + width);
            immutable widthPixels = rightPixels - leftPixels;
            immutable heightPixels = height * multiplier;

            immutable startAt = zeroPoint - heightPixels;

            form.fillClippedRectangle(brush, leftPixels,
                startAt, widthPixels, heightPixels);

            form.drawClippedRectangle(pen, leftPixels,
                startAt, widthPixels, heightPixels);

            // Don't outline rectangle because for equal-frequency
            // histograms this is more distracting than readable.
        }
    }

    override void drawLegendSymbol(FigureBase fig, PlotRect where) {
        drawFillLegend(_barColor, fig, where);
    }

    /**Controls the color of the bar.  Defaults to blue.*/
    final Color barColor()() {
        return _barColor;
    }

    /// Setter
    final This barColor(this This)(Color newColor) {
        _barColor = newColor;
        return cast(This) this;
    }

    /**Create a FrequencyHistogram.  R must be an input range with elements
     * implicitly convertible to double.  nBin must be > 0 and <= nums.length.
     *
     * Throws:  Exception if the density for any bin is infinite.
     */
    static FrequencyHistogram opCall(R)(R nums, uint nBin) {
        auto numArr = toDoubleArray(nums);
        enforce(numArr.length >= nBin,
            "Can't create an equal-frequency histogram w/ < nBin elements.");

        sort(numArr);
        auto binWidths = new double[nBin];

        auto ret = new typeof(return);
        ret.leftLim = numArr[0];
        ret.rightLim = numArr[$ - 1];
        ret.lowerLim = 0;

        // Use linear interpolation to deal w/ non-integer elements/bin.
        immutable elemsPerBin = numArr.length / cast(double) nBin;
        double lastBinStop = numArr[0];
        foreach(i; 0..nBin) {
            immutable floatIndex = elemsPerBin * (i + 1);
            immutable indexFract = floatIndex - floor(floatIndex);
            size_t lowerIndex = to!size_t(floatIndex);
            size_t upperIndex = to!size_t(ceil(floatIndex));

            if(upperIndex >= numArr.length) {
                upperIndex = numArr.length - 1;
            }
            if(lowerIndex >= numArr.length) {
                lowerIndex = numArr.length - 1;
            }

            immutable diff = numArr[upperIndex] - numArr[lowerIndex];
            immutable curBinStop = numArr[lowerIndex] + diff * indexFract;

            binWidths[i] = curBinStop - lastBinStop;
            enforce(binWidths[i] > 0,
                "Can't create an equal-frequency histogram when some bin " ~
                "widths are 0."
            );
            lastBinStop = curBinStop;
        }

        ret.binWidths = binWidths;
        ret.elemsPerBin = elemsPerBin;
        immutable totalWidth = ret.rightLim - ret.leftLim;
        ret.upperLim = totalWidth / reduce!min(binWidths) / elemsPerBin;
        return ret;
    }

    override Figure toLabeledFigure()  {
        auto ret = toFigure;
        ret.yLabel = "Probability Density";
        return ret;
    }
}

/**Creates a histogram in which every unique value gets its own bin.
 * Useful for histograms where the distribution is known to be discrete over
 * a small set of values.
 *
 * Hint:  Since this class inherits from BarPlot, BarPlot.centers will provide
 * a list of the unique values found.  This can be used to label the X
 * axis.
 */
class UniqueHistogram : BarPlot {

    /**The total count of this histogram.*/
    immutable uint nElem;

    private HistType countsOrProbs = HistType.Counts;

    private this(double[] x, double[] y, double width, uint nElem) {
        this.nElem = nElem;
        super(x, y, width);
    }

    /**Create a UniqueHistogram.  R must be an input range with elements
     * implicitly convertible to double.  The width of each bin will be
     * widthFactor times the minimum distance between unique values. widthFactor
     * must be > 0 and <= 1.
     */
    static UniqueHistogram opCall(R)(R nums, double widthFactor = 0.8)
    if(isInputRange!R && isNumeric!(ElementType!R)) {
        enforce(widthFactor > 0 && widthFactor <= 1,
            "widthFactor must be > 0 and <= 1.");

        alias ElementType!R E;

        uint nElem;
        uint[double] counts;
        foreach(num; nums) {
            auto ptr = num in counts;
            if(ptr is null) {
                counts[num] = 1;
            } else {
                (*ptr)++;
            }
            nElem++;
        }

        auto possibleValues = counts.keys;
        sort(possibleValues);
        double minDiff = double.infinity;
        foreach(i; 1..possibleValues.length) {
            minDiff = min(minDiff, possibleValues[i] - possibleValues[i - 1]);
        }

        auto heights = new double[possibleValues.length];
        foreach(i, val; possibleValues) {
            heights[i] = counts[val];
        }

        return new typeof(this)
            (possibleValues, heights, minDiff * widthFactor, nElem);
    }

    /**Set whether this histogram displays counts or probabilities.*/
    void histType(HistType newType)  {
        if(newType == countsOrProbs) {
            return;
        } else if(newType == HistType.Counts) {
            scaleHeights(nElem);
        } else if(newType == HistType.Probability) {
            scaleHeights(1.0 / nElem);
        } else {
            assert(0);
        }

        countsOrProbs = newType;
    }
}

/**Class for drawing a heat map.*/
class HeatMap : Plot {
    private double[][] values;
    private double minVal;
    private double maxVal;
    private uint _nRows;
    private uint _nCols;

    private this() {
        // Set default colors.
        _coldColor = getColor(255, 255, 255);
        _hotColor = getColor(0, 0, 0);
    }

    private Color getCellColor(double val) {
        immutable diff = maxVal - minVal;
        val -= minVal;
        val /= diff;
        immutable compl = 1.0 - val;

        // Bug 4445:  roundTo!ubyte(255.0) throws.
        immutable red = cast(ubyte) roundTo!uint(
            _coldColor.r * compl + _hotColor.r * val);
        immutable green = cast(ubyte) roundTo!uint(
            _coldColor.g * compl + _hotColor.g * val);
        immutable blue = cast(ubyte) roundTo!uint(
            _coldColor.b * compl + _hotColor.b * val);

        return getColor(red, green, blue);
    }

    protected void heatMapDefaultBounds() {
        enforceRectangular();

        _nRows = cast(uint) values.length;
        if(values.length > 0) {
            _nCols = cast(uint) values[0].length;
        }

        leftLim = 0.5;
        rightLim = nCols + 0.5;
        lowerLim = 0.5;
        upperLim = nRows + 0.5;
    }

    protected void setMinMax() {
        minVal = double.infinity;
        maxVal = -double.infinity;

        foreach(row; values) foreach(val; row) {
            minVal = min(minVal, val);
            maxVal = max(maxVal, val);
        }
    }

    protected override void drawLegendSymbol(FigureBase fig, PlotRect where) {
        enforce(0, "Heat maps don't have legends.");
    }

    protected void enforceRectangular() {
        foreach(row; values) {
            enforce(row.length == values[0].length,
                "HeatMap matrices must be rectangular.");
        }
    }

    protected override void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        immutable cellWidth = (rightLim - leftLim) / nCols;
        immutable cellHeight = (upperLim - lowerLim) / nRows;

        if(nRows < 1 || nCols < 1) {
            return;
        }

        mixin(toPixels);
        double lastRowStop = toPixelsY(upperLim);
        foreach(row; 0..nRows) {
            immutable rowStop = toPixelsY(upperLim - cellHeight * (row + 1));
            scope(exit) lastRowStop = rowStop;

            double lastColStop = toPixelsX(leftLim);
            foreach(col; 0..nCols) {
                immutable colStop = toPixelsX(cellWidth * (col + 1) + leftLim);
                scope(exit) lastColStop = colStop;

                auto color = getCellColor(values[row][col]);
                auto rect = PlotRect(lastColStop, lastRowStop,
                    colStop - lastColStop, rowStop - lastRowStop);

                auto brush = form.getBrush(color);
                scope(exit) doneWith(brush);
                auto pen = form.getPen(color, 1);
                scope(exit) doneWith(pen);

                form.fillClippedRectangle(brush, rect);
                form.drawClippedRectangle(pen, rect);
            }
        }
    }

    private Color _coldColor;
    private Color _hotColor;

    /** The color to use for small values.*/
    final Color coldColor()() {
        return _coldColor;
    }

    /// Setter
    final This coldColor(this This)(Color newColor) {
        _coldColor = newColor;
        return cast(This) this;
    }

    /** The color to use for large values.*/
    final Color hotColor()() {
        return _hotColor;
    }

    /// Setter.
    final This hotColor(this This)(Color newColor) {
        _hotColor = newColor;
        return cast(This) this;
    }

    /**Create a heat map from a matrix represented as a range of ranges.
     * The matrix must be rectangular.  The elements of the ranges must
     * be implicitly convertible to double.
     */
    static HeatMap opCall(R)(R data)
    if(isInputRange!R && isInputRange!(ElementType!R) &&
       is(ElementType!(ElementType!(R)) : double)) {
        auto ret = new typeof(this);
        foreach(row; data) {
            ret.values ~= toDoubleArray(row);
        }

        ret.heatMapDefaultBounds();
        ret.setMinMax();
        return ret;
    }

    ///
    final uint nRows()  {
        return _nRows;
    }

    ///
    final uint nCols()  {
        return _nCols;
    }

    /// Throws an exception.  Heat maps aren't allowed to have legends.
    override This legendText(this This)(string ignored) {
        enforce(0, "Heat maps can't have legend text.");
    }
}

/**Creates a heat map representing the density of a 2-d probability
 * distribution.  This is useful when you want to visualize a joint
 * probability distribution but the sample size is so large that a
 * scatter plot would have an overwhelming number of points.
 */
class HeatScatter : HeatMap {
    private double cellWidth;
    private double cellHeight;

    private OutOfBounds outOfBoundsBehavior = OutOfBounds.Throw;

    /**Create a HeatScatter.  x, y must be forward ranges with elements
     * implicitly convertible to double, and must have the same lengths.
     */
    static
    HeatScatter opCall(R1, R2)(R1 x, R2 y, uint nRows = 10, uint nCols = 10)
    if(isForwardRange!R1 && isForwardRange!R2 &&
       is(ElementType!R1 : double) && is(ElementType!R2 : double)) {
        double xMin = double.infinity;
        double xMax = -double.infinity;
        uint xLen;
        foreach(num; x.save) {
            xLen++;
            xMin = min(num, xMin);
            xMax = max(num, xMax);
        }

        double yMin = double.infinity;
        double yMax = -double.infinity;
        uint yLen;
        foreach(num; y.save) {
            yLen++;
            yMin = min(num, yMin);
            yMax = max(num, yMax);
        }

        enforce(xLen == yLen,
            "Can't make HeatScatter when x.length != y.length.");
        return opCall(x, y, nRows, nCols, xMin, xMax, yMin, yMax);
    }

    /**Create a HeatScatter with pre-specified bounds.  x, y must be forward
     * ranges with elements implicitly convertible to double, and must have the
     * same lengths.
     */
    static
    HeatScatter opCall(R1, R2)(R1 x, R2 y, uint nRows, uint nCols,
    double xMin, double xMax, double yMin, double yMax,
    OutOfBounds boundsBehavior = OutOfBounds.Throw)
    if(isForwardRange!R1 && isForwardRange!R2 &&
       is(ElementType!R1 : double) && is(ElementType!R2 : double)) {

        auto ret = opCall(nRows, nCols, xMin, xMax, yMin, yMax, boundsBehavior);

        double maxVal = 0;
        while(!x.empty && !y.empty) {
            scope(exit) {
                x.popFront();
                y.popFront();
            }

            ret.put(x.front(), y.front());
        }

        enforce(x.empty && y.empty,
            "Can't make HeatScatter when x.length != y.length.");
        return ret;
    }

    /**Create a blank HeatScatter to fill in using the put() method.
     *
     * Note:  This is a template only because templates can't be overloaded
     * against regular functions.
     */
    static
    HeatScatter opCall(I)(I nRows, uint nCols,
        double xMin, double xMax, double yMin, double yMax,
        OutOfBounds boundsBehavior = OutOfBounds.Throw) {
        enforce(nRows > 0 && nCols > 0,
            "Can't make a heat scatter with 0 rows or columns.");

        enforce(xMax > xMin, "xMax must be > xMin.");
        enforce(yMax > yMin, "yMax must be > yMin.");

        auto grid = new double[][](nRows, nCols);
        foreach(row; grid) foreach(ref elem; row) {
            elem = 0;
        }

        auto ret = new typeof(return);
        ret.boundsBehavior = boundsBehavior;
        immutable cellWidth = (xMax - xMin) / nCols;
        immutable cellHeight = (yMax - yMin) / nRows;
        ret.cellWidth = cellWidth;
        ret.cellHeight = cellHeight;
        ret.values = grid;
        ret._nRows = nRows;
        ret._nCols = nCols;
        ret.minVal = 0;
        ret.maxVal = 0;
        ret.leftLim = xMin;
        ret.rightLim = xMax;
        ret.lowerLim = yMin;
        ret.upperLim = yMax;
        return ret;
    }

    /**Add an element to the plot.*/
    This put(this This)(double x, double y) {
        bool inBounds() {
            return (x >= leftLim && x <= rightLim && y >= lowerLim &&
            y <= upperLim);
        }

        if(outOfBoundsBehavior == OutOfBounds.Throw) {
            enforce(inBounds(), "Point out of bounds in HeatScatter.");
        } else if(!inBounds()) {
            return cast(This) this;
        }

        uint xCoord = to!uint((x - leftLim) / cellWidth);
        if(xCoord == nCols) {
            xCoord--;
        }

        uint yCoord = nRows - to!uint((y - lowerLim) / cellHeight) - 1;
        if(yCoord == uint.max) {
            yCoord = 0;
        }

        values[yCoord][xCoord]++;
        maxVal = max(maxVal, values[yCoord][xCoord]);

        return cast(This) this;
    }

    /**Add another HeatScatter's data to this.  The boundaries and row and
     * column counts must be the same.  The settings from this HeatScatter are
     * preserved.
     */
    This put(this This)(const HeatScatter rhs) {
        if(rhs is null) {
            return cast(This) this;
        }
        enforce(this.leftLim == rhs.leftLim && this.rightLim == rhs.rightLim &&
                this.upperLim == rhs.upperLim && this.lowerLim == rhs.lowerLim
                && this._nRows == rhs._nRows && this._nCols == rhs._nCols,
        "Cannot combine two HeatScatters w/ different bounds or row/column #s.");

        foreach(row; 0.._nRows) foreach(col; 0.._nCols) {
            this.values[row][col] += rhs.values[row][col];
            this.maxVal = max(this.values[row][col], this.maxVal);
        }

        return cast(This) this;
    }

    /**Determine whether this object throws or ignores if it receives a number
     * outside its bounds via put.
     */
    void boundsBehavior(OutOfBounds behavior) {
        outOfBoundsBehavior = behavior;
    }
}


/**Class for drawing a scatter plot.*/
class ScatterPlot : Plot {
    private double[] x;
    private double[] y;

    protected void addFudgeFactors() {
        // Add fudge factors to bounds to make points not appear off the chart.
        immutable horizFudge = (upperLim - lowerLim) * 0.03;
        immutable verticalFudge = (rightLim - leftLim) * 0.03;
        leftLim -= verticalFudge;
        rightLim += verticalFudge;
        upperLim += horizFudge;
        lowerLim -= horizFudge;
    }

    protected override void drawLegendSymbol(FigureBase fig, PlotRect where) {
        auto font = getFont(plot2kill.util.defaultFont,
            10 + Figure.fontSizeAdjust);

        // Center location.
        string writeThis = [cast(immutable) _pointSymbol];
        immutable meas = fig.measureText(writeThis, font);
        where.y += (where.height - meas.height) / 2;
        where.height = meas.height;

        scope(exit) doneWith(font);
        fig.drawText(writeThis, font, _pointColor, where, TextAlignment.Center);
    }

    protected override void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        enforce(x.length == y.length);  // Should have already been checked.

        if(x.length < 1) {
            return;
        }

        mixin(toPixels);

        auto font = getFont(plot2kill.util.defaultFont,
            10 + Figure.fontSizeAdjust);
        scope(exit) doneWith(font);

        string writeThis = [cast(immutable) _pointSymbol];

        immutable measure = form.measureText(writeThis, font);
        immutable rectWidth = measure.width;
        immutable rectHeight = measure.height;

        foreach(i; 0..x.length) {
            immutable curX = toPixelsX(x[i]);
            immutable curY = toPixelsY(y[i]);
            auto rect = PlotRect(
                curX - rectWidth / 2,
                curY - rectHeight / 2,
                rectWidth,
                rectHeight
            );

            form.drawClippedText(writeThis, font, _pointColor, rect);
        }
    }

    private Color _pointColor;
    private char _pointSymbol = 'x';


    /**The color of each point on the plot.*/
    final Color pointColor()() {
        return _pointColor;
    }

    /// Setter.
    final This pointColor(this This)(Color newColor) {
        _pointColor = newColor;
        return cast(This) this;
    }

    /**The symbol that should be used on the plot.  x and o work pretty well.
     * The default is x.
     */
    final char pointSymbol()() {
        return _pointSymbol;
    }

    /// Setter
    final This pointSymbol(this This)(char newSymbol) {
        _pointSymbol = newSymbol;
        return cast(This) this;
    }

    this() {
        _pointColor = getColor(0, 0, 0);
    }


    /**Factory method for creating a ScatterPlot.  x and y must both be
     * input ranges of the same length, with elements implicitly convertible
     * to doubles.  Note that they are copied inside the factory, so changes
     * to the original ranges after calling this factory will not affect the
     * plot.
     */
    static ScatterPlot opCall(R1, R2)(R1 x, R2 y)
    if(isInputRange!R1 && is(ElementType!R1 : double) &&
       isInputRange!R2 && is(ElementType!R2 : double)) {

        auto ret = new ScatterPlot;
        constructXYGraph(x, y, ret);

        ret.addFudgeFactors();
        return ret;
    }

    /**Convenience factory that produces a ScatterPlot with a default X
     * axis numbered 1, 2, ..., N where N is the number of points.  Mostly
     * useful for quick and dirty plots.
     */
    static ScatterPlot opCall(R)(R y)
    if(isInputRange!R && is(ElementType!R : double)) {
        auto ret = new ScatterPlot;
        ret.y = toDoubleArray(y);
        ret.x = new double[ret.y.length];

        foreach(i, ref elem; ret.x) {
            elem = i + 1;
        }

        fixXYGraphBounds(ret);
        ret.addFudgeFactors();

        return ret;
    }
}

/**Class for drawing a line graph, i.e. a set of points connected by lines.*/
class LineGraph : Plot {
    private double[] x;
    private double[] y;
    private double[] lowerErrors;
    private double[] upperErrors;

    private enum defaultErrorWidth = 0.05;
    private double _errorWidth = defaultErrorWidth;

    protected void fixBounds() {
        this.leftLim = reduce!min(double.infinity, this.x);
        this.rightLim = reduce!max(-double.infinity, this.x);

        this.upperLim = -double.infinity;
        this.lowerLim = double.infinity;
        foreach(i, yCoord; this.y) {
            if(this.lowerErrors.length) {
                this.lowerLim = min(this.lowerLim, yCoord - this.lowerErrors[i]);
            } else {
                this.lowerLim = min(this.lowerLim, yCoord);
            }
            if(this.upperErrors.length) {
                this.upperLim = max(this.upperLim, yCoord + this.upperErrors[i]);
            } else {
                this.upperLim = max(this.upperLim, yCoord);
            }
        }

        if(this.lowerErrors.length || this.upperErrors.length) {
            // Dont' cut off error bars.
            immutable yPad = (this.upperLim - this.lowerLim) * 0.01;
            immutable xPad = (this.rightLim - this.leftLim) * _errorWidth;
            this.leftLim -= xPad;
            this.rightLim += xPad;
            this.upperLim += yPad;
            this.lowerLim -= yPad;
        }
    }

    protected override void drawLegendSymbol(FigureBase fig, PlotRect where) {
        auto pen = fig.getPen(_lineColor, _lineWidth);
        scope(exit) doneWith(pen);
        drawLineLegend(pen, fig, where);
    }

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        enforce(x.length == y.length);  // Should have already been checked.

        if(x.length < 2) {
            return;
        }

        mixin(toPixels);
        mixin(drawErrorMixin);

        immutable absErrorWidth = _errorWidth * (rightLim - leftLim);
        auto errorPen = form.getPen(getColor(0, 0, 0));
        scope(exit) doneWith(errorPen);

        double lastX = toPixelsX(x[0]);
        double lastY = toPixelsY(y[0]);

        void doErrors(size_t index) {
            if(lowerErrors.length) {
                drawErrorBar(
                    errorPen, x[index], y[index],
                        y[index] - lowerErrors[index], absErrorWidth
                );
            }
            if(upperErrors.length) {
                drawErrorBar(
                    errorPen, x[index], y[index],
                        y[index] + upperErrors[index], absErrorWidth
                );
            }
        }

        auto pen = form.getPen(_lineColor, _lineWidth);
        scope(exit) doneWith(pen);

        foreach(i; 1..x.length) {
            immutable curX = toPixelsX(x[i]);
            immutable curY = toPixelsY(y[i]);

            form.drawClippedLine(pen, PlotPoint(lastX, lastY), PlotPoint(curX, curY));
            lastX = curX;
            lastY = curY;
        }

        foreach(i; 0..x.length) {
            doErrors(i);
        }
    }

    private Color _lineColor;
    private uint _lineWidth = 1;

    /**The color of the line.  The default is black.*/
    final Color lineColor()() {
        return _lineColor;
    }

    /// Setter
    final This lineColor(this This)(Color newColor) {
        _lineColor = newColor;
        return cast(This) this;
    }

    /**The width of the line.  The default is 1.*/
    final uint lineWidth()() {
        return _lineWidth;
    }

    /// Setter
    final This lineWidth(this This)(uint newWidth) {
        _lineWidth = newWidth;
        return cast(This) this;
    }

    /**Error bar width, relative to the total width of the plot.  Must be
     * between 0 and 1.  If it's out of bounds, it will be set to the default
     * of 0.05.  If no error bars are to be drawn, this option is ignored.
     */
    final double errorWidth()() {
        return _errorWidth;
    }

    /// Setter
    final This errorWidth(this This)(double newWidth) {
        if(!(newWidth >= 0 && newWidth <= 1)) {
            _errorWidth = defaultErrorWidth;
        } else {
            _errorWidth = newWidth;
        }

        fixBounds();
        return cast(This) this;
    }

    private this() {
        _lineColor = getColor(0, 0, 0);
    }

    /**Factory method for creating a LineGraph.  x and y must both be
     * input ranges of the same length, with elements implicitly convertible
     * to doubles.  Note that they are copied inside the factory, so changes
     * to the original ranges after calling this factory will not affect the
     * plot.
     */
    static LineGraph opCall(R1, R2)(R1 x, R2 y)
    if(isInputRange!R1 && is(ElementType!R1 : double) &&
       isInputRange!R2 && is(ElementType!R2 : double)) {

        auto ret = new LineGraph;
        constructXYGraph(x, y, ret);
        ret.fixBounds();
        return ret;
    }

    /**Convenience factory method that produces a LineGraph with a default
     * X axis numbered 1, 2, ..., N, where N is the number of data points,
     * and no error bars.  This is mostly useful for quick and dirty plots.
     */
    static LineGraph opCall(R)(R y)
    if(isInputRange!R && is(ElementType!R : double)) {
        auto ret = new LineGraph;
        ret.y = toDoubleArray(y);
        ret.x = new double[ret.y.length];

        foreach(i, ref elem; ret.x) {
            elem = i + 1;
        }
        ret.fixBounds();
        return ret;
    }

    /**Create a LineGraph with error bars.  lowerErrors and upperErrors
     * must be input ranges with elements implicitly convertible to double for
     * error bars to be shown.  Any other value, such as null or 0, will result
     * in no error bars being shown.  Therefore, to only show, for example,
     * upper erros, simply pass in null or 0 for the lower errors.
     *
     * To draw symmetric error bars, simply pass in the same range for
     * lowerErrors and upperErrors.  However, note that if you do this,
     * the range will need to be a forward range, not an input range.
     */
    static LineGraph opCall(R1, R2, R3, R4)
    (R1 x, R2 y, R3 lowerErrors, R4 upperErrors) {
        auto ret = new typeof(return);
        ret.x = toDoubleArray(x);
        ret.y = toDoubleArray(y);

        enforce(ret.x.length == ret.y.length,
            "x, y must have same length for line/scatter graph.");

        static if(isForwardRange!R3) {
            ret.lowerErrors = toDoubleArray(lowerErrors.save);
        } else static if(isInputRange!R3) {
            ret.lowerErrors = toDoubleArray(lowerErrors);
        }

        static if(isForwardRange!R4) {
            ret.upperErrors = toDoubleArray(upperErrors.save);
        } else static if(isInputRange!R4) {
            ret.upperErrors = toDoubleArray(upperErrors);
        }

        enforce(ret.upperErrors.length == 0 || ret.upperErrors.length ==
            ret.x.length, "Length of upperErrors must equal number of points.");
        enforce(ret.lowerErrors.length == 0 || ret.lowerErrors.length ==
            ret.x.length, "Length of lowerErrors must equal number of points.");

        if(ret.lowerErrors.length == 0 && ret.upperErrors.length == 0) {
            sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y));
        } else if(ret.lowerErrors.length == 0) {
            sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y, ret.upperErrors));
        } else if(ret.upperErrors.length == 0) {
            sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y, ret.lowerErrors));
        } else {
            sort!"a.at!0 < b.at!0"(
                zip(ret.x, ret.y, ret.lowerErrors, ret.upperErrors));
        }

        ret.fixBounds();
        return ret;
    }

    /**Scale this object by a factor of scaleFactor in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void scaleX(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        x[] *= scaleFactor;
        fixBounds();
    }

    /**Scale this object by a factor of scaleFactor in the Y direction.
     * This is useful for getting it onto the same scale as another plot.*/
    void scaleY(double scaleFactor) {
        enforce(isFinite(scaleFactor), "Can't scale by infinity or NaN.");
        y[] *= scaleFactor;
        fixBounds();
    }

    /**Shift this graph by shiftBy units in the X direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void shiftX(double shiftBy) {
        enforce(isFinite(shiftBy), "Can't shift by infinity or NaN.");
        x[] += shiftBy;
        fixBounds();
    }

    /**Shift this graph by shiftBy units in the Y direction.
     * This is useful for getting it onto the same scale as another plot.
     */
    void shiftY(double shiftBy) {
        enforce(isFinite(shiftBy), "Can't shift by infinity or NaN.");
        y[] += shiftBy;
        fixBounds();
    }
}

private void constructXYGraph(T, R1, R2)(R1 x, R2 y, T ret) {
    ret.x = toDoubleArray(x);
    ret.y = toDoubleArray(y);

    enforce(ret.x.length == ret.y.length,
        "x, y must have same length for line/scatter graph.");

    sort!"a.at!0 < b.at!0"(zip(ret.x, ret.y));
    fixXYGraphBounds(ret);
}

private void fixXYGraphBounds(G)(G graph) {
    graph.lowerLim = reduce!min(double.infinity, graph.y);
    graph.upperLim = reduce!max(-double.infinity, graph.y);
    graph.leftLim = reduce!min(double.infinity, graph.x);
    graph.rightLim = reduce!max(-double.infinity, graph.x);

    /* Weird things happen when a graph has zero width or height.  Add fudge
     * factors to correct this.
     */
    with(graph) {
        if(lowerLim == upperLim) {
            lowerLim = nextafter(lowerLim, -double.infinity);
            upperLim = nextafter(upperLim, double.infinity);
        }

        if(leftLim == rightLim) {
            leftLim = nextafter(leftLim, -double.infinity);
            rightLim = nextafter(rightLim, double.infinity);
        }
    }
}

/**Plot a callable object on a range of values.*/
class ContinuousFunction : LineGraph {
    private enum string setupClass = q{
        auto ret = new ContinuousFunction;

        enforce(upperLim > lowerLim,
            "Can't do a function plot if upperLim <= lowerLim.");
        enforce(nEvals >= 2, "Can't do function plot with < 2 evals.");

        immutable diff = upperLim - lowerLim;
        immutable width = diff / (nEvals - 1);
        auto x = new double[nEvals];
        auto y = new double[nEvals];

        foreach(i; 0..nEvals) {
            x[i] = i * width + lowerLim;
            y[i] = callable(x[i]);
        }

        ret.x = x;
        ret.y = y;
        fixXYGraphBounds(ret);
        return ret;
    };

    /**Create a ContinuousFunction.  C is any callable type mapping a floating
     * point number to a number.  lowerLim is the lower limit of the plot.
     * upperLim is the upper limit of the plot.  nEvals is the number of
     * evalutations to perform.  The default is 1000.  More evaluations means
     * more accuracy but more computational intensity.
     */
    static ContinuousFunction opCall(C)(
        scope C callable,
        double lowerLim,
        double upperLim,
        uint nEvals = 1000
    ) if(is(typeof(C.init(2.0)) : double)) {
        // For some reason doing return opCall!callable doesn't work.
        // Using mixin instead.
        mixin(setupClass);
    }

    /**Create a ContinuousFunction using a template alias parameter instead of
     * a callable object.
     *
     * Note:  This function is given an name instead of opCall because DMD
     * thinks you're trying to instantiate a class if you do
     * ContinuousFunction!fun(...).
     */
    static ContinuousFunction fromAlias(alias callable)(
        double lowerLim,
        double upperLim,
        uint nEvals = 1000
    ) if(is(typeof(callable(2.0)) : double)) {
        mixin(setupClass);
    }

}

/**Plot a callable object on a range of values.*/
class DiscreteFunction : BarPlot {

    private this(double[] x, double[] y) {
        super(x, y, 1);
    }

    /**Create a DiscreteFunction. C is any callable type mapping an integer
     * to a number.  lowerLim is the lower limit of the plot.
     * upperLim is the upper limit of the plot.
     */
    static DiscreteFunction opCall(C)(
        scope C callable,
        int lowerLim,
        int upperLim,
    ) if(is(typeof(C.init(2)) : double)) {
        enforce(upperLim > lowerLim,
            "Can't do a function plot if upperLim <= lowerLim.");

        static if(is(typeof(C.opCall))) {
            alias ParameterTypeTuple!(C.opCall)[0] I;
        } else {
            alias ParameterTypeTuple!(C)[0] I;
        }

        I input = to!I(lowerLim);
        double[] x = new double[upperLim - lowerLim + 1];
        double[] y = new double[upperLim - lowerLim + 1];

        foreach(ulIndex; 0..x.length) {
            immutable index = cast(int) ulIndex;
            x[index] = lowerLim + index;
            y[index] = callable(input);
            input++;
        }

        auto ret = new typeof(return)(x, y);
        ret.fixBounds();
        return ret;
    }

    /**Create a DiscreteFunction using a template alias parameter instead of
     * a callable object.
     *
     * Note:  This function is given an name instead of opCall because DMD
     * thinks you're trying to instantiate a class if you do
     * ContinuousFunction!fun(...).
     */
    static DiscreteFunction fromAlias(alias callable)(
        int lowerLim,
        int upperLim,
    ) if(is(typeof(callable(2)) : double)) {
        enforce(upperLim > lowerLim,
            "Can't do a function plot if upperLim <= lowerLim.");

        int input = lowerLim;
        double[] x = new double[upperLim - lowerLim + 1];
        double[] y = new double[upperLim - lowerLim + 1];

        foreach(int index; 0..x.length) {
            x[index] = lowerLim + index;
            y[index] = callable(input);
            input++;
        }

        auto ret = new typeof(return)(x, y);
        ret.fixBounds();
        return ret;
    }
}

// Above was relatively basic plots.  Below is more specialized statistical
// plots.

/**Plots a ROC curve, or a curve with sensitivity on the Y-axis
 * and 1 - specificity on the X-axis.  This is a useful metric for
 * determining how well a test statistic discriminates between two classes.
 * The following assumptions are made in this implementation:
 *
 * 1.  For some cutoff value c and test statistic T, your decision rule is of
 *     the form "Class A if T larger than c, Class B if T smaller than c".
 *
 * 2.  In the case of ties, i.e. if class A and class B both have an identical
 *     value, linear interpolation is used.  This is because changing the
 *     value of c infinitesimally will change both sensitivity and specificity
 *     in these cases.
 */
class RocCurve : LineGraph {
private:
    double _auroc;

    this() {
        super();
    }

public:
    /**Create a RocCurve.  classATs are the test statistics that are
     * "supposed" to be bigger, classBTs are the test statistics that are
     * "supposed to be smaller.  Both R1 and R2 must be input ranges with
     * elements implicitly convertible to double.
     */
    static RocCurve opCall(R1, R2)(R1 classATs, R2 classBTs)
    if(isNumeric!(ElementType!R1) && isNumeric!(ElementType!R2)) {
        // Shamelessly cut-and-pasted and modified from dstats.

        auto classA = array(classATs);
        auto classB = array(classBTs);
        sort(classA);
        sort(classB);

        // Start cutoff at -infinity, such that we get everything in class A, i.e.
        // perfect specificity, zero sensitivity.  We arbitrarily define class B
        // as our "positive" class.
        double tp = 0, tn = classA.length, fp = 0, fn = classB.length;
        double[2] lastPoint = 0;

        Unqual!(CommonType!(ElementType!R1, ElementType!R2)) currentVal;

        ElementType!R1 popA() {
            tn--;
            fp++;
            auto ret = classA.front();
            classA.popFront();
            return ret;
        }

        ElementType!R2 popB() {
            fn--;
            tp++;
            auto ret = classB.front();
            classB.popFront();
            return ret;
        }

        double area = 0;
        double[] x = [0.0];
        double[] y = [0.0];
        while(!classA.empty && !classB.empty) {
            if(classA.front() < classB.front()) {
                currentVal = popA();
            } else {
                currentVal = popB();
            }

            // Handle ties.
            while(!classA.empty && classA.front() == currentVal) {
                popA();
            }

            while(!classB.empty && classB.front() == currentVal) {
                popB();
            }

            double[2] curPoint;
            curPoint[0] = 1.0 - tn / (fp + tn);
            curPoint[1] = tp / (tp + fn);

            x ~= curPoint[0];
            y ~= curPoint[1];

            immutable xDist = curPoint[0] - lastPoint[0];
            area += xDist * lastPoint[1];  // Rectangular part.
            area += xDist * 0.5 * (curPoint[1] - lastPoint[1]);  // Triangular part.
            lastPoint[] = curPoint[];
        }

        if(classA.length > 0 && classB.length == 0) {
            // Then we already have a sensitivity of 1, move straight to the right
            // to the point (1, 1).

            immutable xDist = 1 - lastPoint[0];
            area += xDist * lastPoint[1];  // Rectangular part.
            area += xDist * 0.5 * (1 - lastPoint[1]);  // Triangular part.
        }

        x ~= 1;
        y ~= 1;

        auto ret = new typeof(return)();
        ret._auroc = area;
        ret.x = x;
        ret.y = y;
        fixXYGraphBounds(ret);
        return ret;
    }

    /**Returns the area under the ROC curve.*/
    final double auroc() const pure nothrow  {
        return _auroc;
    }

    /**Default title is the area under the curve.  Default x label is
     * "1 - Specificity".  Default y label is "Sensitivity".
     */
    Figure toLabeledFigure()  {
        auto ret = toFigure;
        ret.title = "AUROC = " ~ to!string(auroc);
        ret.xLabel = "1 - Specificity";
        ret.yLabel = "Sensitivity";
        return ret;
    }
}

unittest {
    // Values worked out by hand on paper.  If you don't believe me, work
    // them out yourself.
    auto foo = RocCurve([4,5,6], [1,2,3]);
    assert(foo.auroc == 1);

    foo = RocCurve([8,6,7,5,3,0,9], [3,6,2,4,3,6]);
    assert(approxEqual(foo.auroc, 0.6904762));

    foo = RocCurve([2,7,1,8,2,8,1,8], [3,1,4,1,5,9,2,6]);
    assert(approxEqual(foo.auroc, 0.546875));
}

/**Plots the quantiles of a set of data on the Y axis against the theoretical
 * qualtiles or the quantiles of another set of data on the X axis.
 */
class QQPlot : ScatterPlot {
    private this() {
        super();
        _lineColor = getColor(255, 0, 0);
    }

    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        super.drawPlot(
            form, leftMargin, topMargin, plotWidth, plotHeight
        );

        // Draw line that indicates identical distributions.
        if(max(lowerLim, leftLim) < min(upperLim, rightLim)) {
            mixin(toPixels);

            auto pen = form.getPen(_lineColor, _lineWidth);
            scope(exit) doneWith(pen);

            immutable lowerX = toPixelsX(max(lowerLim, leftLim));
            immutable lowerY = toPixelsY(max(lowerLim, leftLim));
            immutable upperX = toPixelsX(min(upperLim, rightLim));
            immutable upperY = toPixelsY(min(upperLim, rightLim));

            form.drawClippedLine(
                pen,
                PlotPoint(lowerX, lowerY),
                PlotPoint(upperX, upperY)
            );
        }
    }

    private Color _lineColor;

    /**The color of the y = x line that indicates identical distributions.
     * The default is red.
     */
    final Color lineColor()() {
        return _lineColor;
    }

    /// Setter
    final This lineColor(this This)(Color newColor) {
        _lineColor = newColor;
        return cast(This) this;
    }

    private double _lineWidth = 2;

    /**The width of the line that indicates identical distributions.
     * The default is 2.
     */
    final double lineWidth()() {
        return _lineWidth;
    }

    /// Setter.
    final This lineWidth(this This)(double newWidth) {
        _lineWidth = newWidth;
        return cast(This) this;
    }

    /**Create a QQPlot.  dataRange must be an input range with elements
     * implicitly convertible to doubles.  quantileFunction must be a
     * callable (function pointer, delegate, functor, etc.) mapping any
     * number between 0 and 1 to its quantile.
     *
     * Examples:
     * ---
     * auto norms = randArray!rNorm(100, 0, 1);
     * auto theoretical = paramFunctor!invNormalCDF(0, 1);
     * auto fig = new Figure(
     *     QQPlot(norms, theoretical)
     * );
     * fig.showAsMain();
     * ---
     */
    static QQPlot opCall(R, C)(R dataRange, C quantileFunction)
    if(is(typeof(C.init(2.0)) : double) && isInputRange!R &&
    is(ElementType!R : double)) {
        auto ret = new QQPlot;

        ret.y = toDoubleArray(dataRange);
        sort(ret.y);
        immutable double N = ret.y.length + 1.0;

        ret.x = new double[ret.y.length];
        foreach(i, ref elem; ret.x) {
            elem = quantileFunction((i + 1) / N);
        }

        fixXYGraphBounds(ret);
        ret.addFudgeFactors();
        return ret;
    }

    /**Default x label is "Theoretical Quantiles".  Default y label is
     * "Empirical Quantiles".
     */
    Figure toLabeledFigure() {
        auto ret = toFigure;
        ret.xLabel = "Theoretical Quantiles";
        ret.yLabel = "Empirical Quantiles";
        return ret;
    }
}

/**
Draw a basic box-and-whisker plot.  The plots are drawn centered at Y
coordinates [0, 1, ..., N).
*/
class BoxPlot : Plot {
private:
    double[] medians;
    double[] boxBottoms;
    double[] boxTops;
    double[] whiskerBottoms;
    double[] whiskerTops;
    double[][] outliers;
    double whiskerPercentile;

    void updateBounds() {
        if(medians.length == 0) return;

        upperLim = reduce!max(-double.infinity,
            chain(whiskerTops, join(outliers))
        );

        lowerLim = reduce!min(double.infinity,
            chain(whiskerBottoms, join(outliers))
        );

        immutable diff = upperLim - lowerLim;
        upperLim += 0.01 * diff;
        lowerLim -= 0.01 * diff;

        leftLim = -0.6;
        rightLim = medians.length - 0.4;

    }

    void addDataImpl(R)(R range) {
        auto doubles = toDoubleArray(range);
        enforce(doubles.length,
            "Cannot add a zero-length range to a box and whisker plot.");
        sort(doubles);

        if(doubles.length & 1) {
            medians ~= doubles[$ / 2];
        } else {
            medians ~= 0.5 * doubles[$ / 2] + 0.5 * doubles[$ / 2 + 1];
        }

        double doInterp(double percentile) {
            immutable floatIndex = percentile * (doubles.length - 1);
            immutable floored = to!size_t(floatIndex);
            immutable fract = floatIndex - floored;

            if(fract == 1 || floored == doubles.length - 1) {
                return doubles[floored];
            } else {
                return fract * doubles[floored] +
                    (1 - fract) * doubles[floored + 1];
            }
        }

        boxBottoms ~= doInterp(0.25);
        boxTops ~= doInterp(0.75);
        whiskerBottoms ~= doInterp(whiskerPercentile);
        whiskerTops ~= doInterp(1 - whiskerPercentile);

        immutable whiskerTopIndex = to!size_t(
            ceil((1 - whiskerPercentile) * (doubles.length - 1)) + 1
        );
        immutable whiskerBottomIndex = to!size_t(
            whiskerPercentile * (doubles.length - 1)
        );

        auto outlierRange = chain(
            doubles[0..whiskerBottomIndex],
            doubles[whiskerTopIndex..$]
        );

        outliers.length += 1;

        foreach(outlier; outlierRange) {
            outliers[$ - 1] ~= outlier;
        }

        // We're absolutely sure we don't need doubles anymore, and may
        // be working with huge datasets.
        delete doubles;

        updateBounds();
    }

protected:
    protected void drawPlot(
        Figure form,
        double leftMargin,
        double topMargin,
        double plotWidth,
        double plotHeight
    ) {
        mixin(toPixels);
        immutable nBoxes = medians.length;
        immutable boxWidth = 1;

        auto pen = form.getPen(getColor(0, 0, 0), 1);

        foreach(boxIndex, med; medians) {
            immutable left = boxWidth * boxIndex + 0.15 - 0.5;
            immutable center = boxWidth * boxIndex;
            immutable right = boxWidth * boxIndex + 0.85 - 0.5;
            immutable wLeft = boxWidth * boxIndex + 0.35 - 0.5;
            immutable wRight = boxWidth * boxIndex + 0.65 - 0.5;

            immutable leftPixels = toPixelsX(left);
            immutable centerPixels = toPixelsX(center);
            immutable rightPixels = toPixelsX(right);
            immutable wLeftPixels = toPixelsX(wLeft);
            immutable wRightPixels = toPixelsX(wRight);
            immutable boxTopPixels = toPixelsY(boxTops[boxIndex]);
            immutable boxBotPixels = toPixelsY(boxBottoms[boxIndex]);
            immutable wTopPixels = toPixelsY(whiskerTops[boxIndex]);
            immutable wBotPixels = toPixelsY(whiskerBottoms[boxIndex]);

            // Draw box.
            form.drawClippedLine(
                pen,
                PlotPoint(leftPixels, boxBotPixels),
                PlotPoint(leftPixels, boxTopPixels)
            );

            form.drawClippedLine(
                pen,
                PlotPoint(rightPixels, boxBotPixels),
                PlotPoint(rightPixels, boxTopPixels)
            );

            form.drawClippedLine(
                pen,
                PlotPoint(leftPixels, boxBotPixels),
                PlotPoint(rightPixels, boxBotPixels)
            );

            form.drawClippedLine(
                pen,
                PlotPoint(leftPixels, boxTopPixels),
                PlotPoint(rightPixels, boxTopPixels)
            );

            // Draw median lines.
            form.drawClippedLine(
                pen,
                PlotPoint(leftPixels, toPixelsY(med)),
                PlotPoint(rightPixels, toPixelsY(med))
            );


            // Draw whiskers.
            form.drawClippedLine(
                pen,
                PlotPoint(centerPixels, boxTopPixels),
                PlotPoint(centerPixels, wTopPixels)
            );

            form.drawClippedLine(
                pen,
                PlotPoint(centerPixels, boxBotPixels),
                PlotPoint(centerPixels, wBotPixels)
            );

            form.drawClippedLine(
                pen,
                PlotPoint(wLeftPixels, wBotPixels),
                PlotPoint(wRightPixels, wBotPixels)
            );

            form.drawClippedLine(
                pen,
                PlotPoint(wLeftPixels, wTopPixels),
                PlotPoint(wRightPixels, wTopPixels)
            );

            if(whiskerPercentile == 0) continue;

            // Draw outliers.
            auto font = getFont(plot2kill.util.defaultFont,
                10 + Figure.fontSizeAdjust);
            scope(exit) doneWith(font);

            string writeThis = "o";

            immutable measure = form.measureText(writeThis, font);
            immutable rectWidth = measure.width;
            immutable rectHeight = measure.height;

            foreach(outlier; outliers[boxIndex]) {
                immutable curY = toPixelsY(outlier);
                auto rect = PlotRect(
                    centerPixels - rectWidth / 2,
                    curY - rectHeight / 2,
                    rectWidth,
                    rectHeight
                );

                form.drawClippedText(writeThis, font, getColor(0, 0, 0), rect);
            }
        }
    }

    override void drawLegendSymbol(FigureBase fig, PlotRect where) {
        auto pen = fig.getPen(getColor(0, 0, 0), 1);
        scope(exit) doneWith(pen);
        drawLineLegend(pen, fig, where);
    }

public:

    /**
    Create a BoxPlot.  whiskerPercentile controls the percentile at which
    data points are considered outliers and plotted as individual points.
    For any x, a percentile of x is equivalent to a percentile of 1 - x.
    For example, if whiskerPercentile is either 0 or 1, no data is plotted as
    individual points and the whiskers extend all the way to the extrema.
    */
    static BoxPlot opCall(double whiskerPercentile = 0) {
        enforce(whiskerPercentile >= 0 && whiskerPercentile <= 1,
            "whiskerPercentile must be between 0 and 1.");
        auto ret = new BoxPlot;
        ret.whiskerPercentile = min(whiskerPercentile, 1 - whiskerPercentile);
        return ret;
    }

    /**
    Add data to the box plot.  data may be any combination of ranges of
    ranges and individual ranges.
    */
    This addData(this This, R...)(R data)
    if(allSatisfy!(isInputRange, R)) {
        foreach(r; data) {
            static if(isInputRange!(ElementType!(typeof(r)))) {
                foreach(rr; r) addDataImpl(rr);
            } else {
                addDataImpl(r);
            }
        }

        return cast(This) this;
    }

}

private:

void drawLineLegend(Pen pen, FigureBase fig, PlotRect where) {
    auto mid = where.y + where.height / 2;
    fig.drawLine(pen,
        PlotPoint(where.x, mid),
        PlotPoint(where.x + where.width, mid));
}

void drawFillLegend(Color color, FigureBase fig, PlotRect where) {
    auto brush = fig.getBrush(color);
    scope(exit) doneWith(brush);
    fig.fillRectangle(brush, where.x, where.y, where.width, where.height);
}
