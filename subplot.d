/**This module contains subplot windows.  The details of these depend on the
 * GUI lib in question.
 *
 * Copyright (C) 2010 David Simcha
 *
 * License:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module plot2kill.subplot;

import plot2kill.figure;

import plot2kill.util;

// The Subplot window code is GUI-specific enough that I consider it the
// lesser of two evils to have completely separate implementations for each
// GUI lib and accept a small amount of duplication, rather than create a
// rat's nest trying to abstract away the small amount of GUI-agnostic
// logic that the Subplot contains.  Therefore, the proper way to port this
// to a new GUI framework is clone and modify.
//
// Once the design of the Subplot window is pinned down a little better, it
// might make sense to abstract some common functionality to a mixin, but
// probably not to any more formal, OO-based abstraction.

version(dfl) {

import dfl.form, dfl.label, dfl.control, dfl.event, dfl.picturebox, dfl.base,
    dfl.application;

/**Allows for one or more subplots to be created in a single window.  Each
 * subplot is represented by a Figure.  Double-clicking on any subplot zooms
 * in on it.  Double-clicking again zooms out.
 *
 * Note:  When this class is passed a Figure, it assumes complete ownership of
 * that Figure and will feel free to mess around with its internal state.
 *
 * Examples:
 * ---
 * auto hist = Histogram(someNumbers, 10);
 * auto histFig = new Figure(hist);
 * auto scatter = ScatterPlot(someNumbers, someMoreNumbers);
 * auto scatterFig = new Figure(scatter);
 * auto sub = new SubPlot(1, 2);  // 1 row, 2 columns.
 * sub.addPlot(histFig, 0, 0);  // Add the histogram in the 0th row, 0th column.
 * sub.addPlot(scatterFig, 0, 1);  // Ditto.
 * sub.show();
 * ---
 */
class Subplot : ContainerControl {
    mixin(labelStuff);

private:
    // Fudge factors for the space that window borders take up.  TODO:
    // Figure out how to get the actual numbers and use them instead of these
    // stupid fudge factors.
    enum verticalBorderSize = 40;
    enum horizontalBorderSize = 10;

    uint nRows;
    uint nColumns;

    int verticalMargin = 60;
    int horizontalMargin = 60;

    Figure[][] figs;
    Figure zoomedFigure;

    Label titleObj;
    Label xLabelObj;
    Label yLabelObj;

    invariant() {
        assert(figs.length == nRows);
        foreach(row; figs) {
            assert(row.length == nColumns);
        }
    }

    void nullFontsToDefaults() {
        if(titleFont is null) {
            titleFont = getFont(plot2kill.util.defaultFont, 18);
            assert(titleFont);
        }

        if(xLabelFont is null) {
            xLabelFont = getFont(plot2kill.util.defaultFont, 14);
            assert(xLabelFont);
        }

        if(yLabelFont is null) {
            yLabelFont = getFont(plot2kill.util.defaultFont, 14);
            assert(yLabelFont);
        }
    }

    void drawLabels() {
        nullFontsToDefaults();

        if(title.length == 0 && xLabel.length == 0) {
            verticalMargin = 0;
            xLabelObj.parent = null;
            yLabelObj.parent = null;
        } else {
            verticalMargin = 30;
            xLabelObj.text = xLabel;
            titleObj.text = title;

            xLabelObj.setBounds(0, height - verticalMargin - verticalBorderSize,
                this.width, verticalMargin
            );
            titleObj.setBounds(0, 0, this.width, verticalMargin);
            titleObj.parent = this;
            xLabelObj.parent = this;
        }

        if(yLabel.length == 0) {
            horizontalMargin = 0;
            yLabelObj.parent = null;
        } else {
            horizontalMargin = 30;
            yLabelObj.text = addNewlines(yLabel);
            yLabelObj.setBounds(0, 0, horizontalMargin, this.height);
            yLabelObj.parent = this;
        }
    }

    void zoomInOn(Control c, EventArgs ea) {
        if(zoomedFigure is null) {
            zoomedFigure = cast(Figure) c;

        } else {
            zoomedFigure = null;
        }

        drawFigure();
    }

    void drawFigureZoomedOut() {
        this.text = "Double-click a figure to zoom in on it.";
        drawLabels();
        immutable figWidth = (this.width -  horizontalBorderSize
            - 2 * horizontalMargin) / nColumns;
        immutable figHeight = (this.height - verticalBorderSize
            - 2 * verticalMargin) / nRows;

        foreach(rowIndex, row; figs) {
            foreach(colIndex, fig; row) {
                if(fig is null) {
                    continue;
                }

                immutable xPos = colIndex * figWidth + horizontalMargin;
                immutable yPos = rowIndex * figHeight + verticalMargin;
                fig.parent = this;
                fig.size = Size(figWidth, figHeight);
                fig.location = Point(xPos, yPos);
                fig.bringToFront();
            }
        }
    }

    void drawFigureZoomedIn() {
        this.text = "Double-click again to zoom out.";

        zoomedFigure.parent = this;
        zoomedFigure.setBounds(0, 0,
            width - horizontalBorderSize, height - verticalBorderSize);
        zoomedFigure.bringToFront();
    }


    void resizeEvent(Control c, EventArgs ea) {
        drawFigure();
    }

protected:

    this(uint nRows, uint nColumns) {
        enforce(nRows >= 1 && nColumns >= 1,
            "Subplot figures must have at least 1 cell.  Can't create a " ~
            " subplot of dimensions " ~ to!string(nRows) ~ "x" ~
            to!string(nColumns) ~ "."
        );

        size = Size(1024 + horizontalBorderSize,
                    768 + verticalBorderSize);

        this.nRows = nRows;
        this.nColumns = nColumns;

        figs = new Figure[][](nRows, nColumns);
        titleObj = new Label;
        xLabelObj = new Label;
        yLabelObj = new Label;

        titleObj.textAlign = ContentAlignment.MIDDLE_CENTER;
        xLabelObj.textAlign = ContentAlignment.MIDDLE_CENTER;
        yLabelObj.textAlign = ContentAlignment.MIDDLE_CENTER;

        resize ~= &resizeEvent;
    }

public:

    /**Create an instance with nRows rows and nColumns columns.*/
    static Subplot opCall(uint nRows, uint nColumns) {
        return new Subplot(nRows, nColumns);
    }

    /**Add a figure to the subplot in the given row and column.  fig is passed
     * in by reference, and the handle passed in is set to null.  This is
     * to emphasize the fact that the Subplot class assumes ownership of the
     * figure class and is free to modify the Figure's internal state.
     *
     * This function returns this to allow for a fluent interface.
     */
    Subplot addFigure(ref Figure fig, uint row, uint col) {
        enforce(row < nRows && col < nColumns, std.conv.text(
            "Can't add a plot to cell (",row, ", ", col, ") of a ", nRows,
            "x", nColumns, " Subplot."));

        // TODO:  Figure out why the double click event goes to the picture
        // box and not to fig.
        fig.doubleClick ~= &zoomInOn;
        figs[row][col] = fig;
        fig = null;

        return this;
    }

    /// Convenience function in case fig isn't an lvalue.
    final void addFigure(Figure fig, uint row, uint col) {
        return addFigure(fig, row, col);
    }

    // Kludge:  Use columnar text for y label until we get some rotated text.
    // TODO:  Get rid of this )#$* function.
    static string addNewlines(string orig) {
        string ret;
        foreach(dchar c; orig[0..$ - 1]) {
            ret ~= c;
            ret ~= '\n';
        }
        ret ~= orig[$ - 1];
        return ret;
    }

    /**Draw the figure, but don't display it.*/
    void drawFigure() {
        if(zoomedFigure is null) {
            drawFigureZoomedOut();
        } else {
            drawFigureZoomedIn();
        }
    }

    /**Redraws this control.  Useful as something to attach to a parent control.*/
    void drawFigureEvent(Control c, EventArgs ea) {
        drawFigure();
    }

    /**Sets this.size to parent.size and dedraws.  Again, useful for
     * attaching to parent controls.
     */
    void parentResize(Control c, EventArgs ea) {
        this.size = Size(parent.width, parent.height);
        drawFigure();
    }

    /**Draw and display the figure as a main form.  This is useful in
     * otherwise console-based apps that want to display a few plots.
     * However, you can't have another main form up at the same time.
     */
    void showAsMain() {
        auto mainForm = new Form;
        mainForm.minimumSize = Size(800 + horizontalBorderSize,
                                    600 + verticalBorderSize);
        mainForm.size = this.size;
        this.parent = mainForm;
        mainForm.activated ~= &drawFigureEvent;
        mainForm.resize ~= &parentResize;

        auto ac = new ApplicationContext;
        ac.mainForm = mainForm;
        Application.run(ac);
    }
}
}

version(gtk) {
import gtk.MainWindow, gtk.Label, gtk.Main, gtk.Widget, gtk.VBox, gtk.HBox,
    gtk.DrawingArea, gtk.Table, gtk.Container, gtkc.gdktypes,
    gdk.Drawable, gdk.Pixmap, gdk.Pixbuf, gdk.GC;

/**Allows for one or more subplots to be created in a single window.  Each
 * subplot is represented by a Figure.  Double-clicking on any subplot zooms
 * in on it.  Double-clicking again zooms out.
 *
 * Note:  When this class is passed a Figure, it assumes complete ownership of
 * that Figure and will feel free to mess around with its internal state.
 *
 * Examples:
 * ---
 * auto hist = Histogram(someNumbers, 10);
 * auto histFig = new Figure(hist);
 * auto scatter = ScatterPlot(someNumbers, someMoreNumbers);
 * auto scatterFig = new Figure(scatter);
 * auto sub = new SubPlot(1, 2);  // 1 row, 2 columns.
 * sub.addPlot(histFig, 0, 0);  // Add the histogram in the 0th row, 0th column.
 * sub.addPlot(scatterFig, 0, 1);  // Ditto.
 * sub.show();
 * ---
 */
class Subplot : PlotDrawingBase {

    mixin(labelStuff);

private:
    uint nRows;
    uint nColumns;

    int topMargin;
    int bottomMargin;
    int leftMargin;
    enum int rightMargin = 30;  // No label here so it can be an enum.

    Figure[][] figs;
    Figure zoomedFigure;

    invariant() {
        assert(figs.length == nRows);
        foreach(row; figs) {
            assert(row.length == nColumns);
        }
    }

    void nullFontsToDefaults() {
        if(titleFont is null) {
            titleFont = getFont(plot2kill.util.defaultFont, 18);
            assert(titleFont);
        }

        if(xLabelFont is null) {
            xLabelFont = getFont(plot2kill.util.defaultFont, 14);
            assert(xLabelFont);
        }

        if(yLabelFont is null) {
            yLabelFont = getFont(plot2kill.util.defaultFont, 14);
            assert(yLabelFont);
        }
    }

    void drawLabels() {
        if(textPen is null) {
            textPen = new GC(drawable);
        }

        // The amount of margin that's left before the labels are even drawn.
        enum labelMargin = 10;
        nullFontsToDefaults();
        if(xLabel.length > 0) {
            immutable textSize = measureText(xLabel, xLabelFont);
            bottomMargin = textSize.height + labelMargin;
            drawText(
                xLabel, xLabelFont, getColor(0, 0, 0),
                Rect(0,
                    this.height - bottomMargin,
                    this.width, textSize.height),
                TextAlignment.Center
            );
        } else {
            bottomMargin = 0;
        }

        if(title.length > 0) {
            immutable textSize = measureText(title, titleFont);
            topMargin = textSize.height + labelMargin;
            drawText(
                title, titleFont, getColor(0, 0, 0),
                Rect(0, labelMargin, width, topMargin - labelMargin),
                TextAlignment.Center
            );
        } else {
            topMargin = 0;
        }

        if(yLabel.length > 0) {
            immutable textSize = measureText(yLabel, yLabelFont);
            leftMargin = textSize.height + labelMargin;
            drawRotatedText(
                yLabel, yLabelFont, getColor(0, 0, 0),
                Rect(labelMargin, 0, textSize.height, this.height),
                TextAlignment.Center
            );
        }
    }

    int getFigWidth() {
        return (this.width - rightMargin - leftMargin) / nColumns;
    }

    int getFigHeight() {
        return (this.height - topMargin - bottomMargin) / nRows;
    }


    void drawFigureZoomedOut() {
        if(!getParent() && !drawable) {
            return;
        }

        if(!drawable) {
            realize();
            drawable = getWindow();
        }


        auto gc = new GC(drawable);
        scope(exit) doneWith(gc);

        gc.setForeground(new Color(255, 255, 255));
        drawable.drawRectangle(gc, 1, 0, 0, width, height);
        drawLabels();

        immutable figWidth = getFigWidth();
        immutable figHeight = getFigHeight();

        foreach(rowIndex, row; figs) {
            foreach(colIndex, fig; row) {
                if(fig is null) {
                    continue;
                }

                immutable xPos = colIndex * figWidth + leftMargin + xOffset;
                immutable yPos = rowIndex * figHeight + topMargin + yOffset;
                auto whereToDraw = Rect(xPos, yPos, figWidth, figHeight);
                fig.drawToRaster(drawable, whereToDraw);
            }
        }

        // Temporary kludge:  Draw labels a second time to prevent them
        // from being cut off by plots.  Linux's text measuring sucks.
        drawLabels();
    }

    // Bugs:  Doesn't work.
    void drawFigureZoomedIn() {
        // Should always have been initialized by now:
        assert(drawable !is null);
        assert(zoomedFigure !is null);

        zoomedFigure.drawToRaster
            (drawable, Rect(xOffset, yOffset, width, height));
        this.showAll();
    }

    bool onDrawingExpose(GdkEventExpose* event, Widget drawingArea) {
        drawFigure();
        return true;
    }

    void windowResized(GtkRequisition* req, Widget w) {
        if(req.width != this.width || req.height != this.height) {
            drawFigure();
        }
    }

    Figure getFigureAt(double x, double y) {
        if(x < leftMargin || y < topMargin) {
            return null;
        }

        immutable figWidth = getFigWidth();
        immutable figHeight = getFigHeight();


        immutable xCoord = to!int((x - leftMargin) / figWidth);
        immutable yCoord = to!int((y - topMargin) / figHeight);
        if(xCoord < nColumns && yCoord < nRows) {
            return figs[yCoord][xCoord];
        } else {
            return null;
        }
    }

    bool zoomEvent(GdkEventButton* press, Widget widget) {
        if(press.type != GdkEventType.DOUBLE_BUTTON_PRESS || press.button != 1) {
            return false;
        }

        if(zoomedFigure is null) {
            auto toZoom = getFigureAt(press.x, press.y);
            if(toZoom !is null) {
                zoomedFigure = toZoom;
                drawFigureZoomedIn();
            }
        } else {
            zoomedFigure = null;
            drawFigureZoomedOut();
        }

        return true;
    }

protected:

    this(uint nRows, uint nColumns) {
        enforce(nRows >= 1 && nColumns >= 1,
            "Subplot figures must have at least 1 cell.  Can't create a " ~
            " subplot of dimensions " ~ to!string(nRows) ~ "x" ~
            to!string(nColumns) ~ "."
        );

        this.setUsize(800, 600);

        this.nRows = nRows;
        this.nColumns = nColumns;

        figs = new Figure[][](nRows, nColumns);
        this.addOnSizeRequest(&windowResized);
        this.addOnExpose(&onDrawingExpose);
        this.addOnButtonPress(&zoomEvent);
    }

    override void draw() {
        drawFigure();
    }

public:

    /**Create an instance with nRows rows and nColumns columns.*/
    static Subplot opCall(uint nRows, uint nColumns) {
        return new Subplot(nRows, nColumns);
    }

    /**Add a figure to the subplot in the given row and column.  fig is passed
     * in by reference, and the handle passed in is set to null.  This is
     * to emphasize the fact that the Subplot class assumes ownership of the
     * figure class and is free to modify the Figure's internal state.
     *
     * This function returns this to allow for a fluent interface.
     */
    Subplot addFigure(ref Figure fig, uint row, uint col) {
        enforce(row < nRows && col < nColumns, std.conv.text(
            "Can't add a plot to cell (",row, ", ", col, ") of a ", nRows,
            "x", nColumns, " Subplot."));

        figs[row][col] = fig;
        fig.addOnButtonPress(&zoomEvent);
        fig = null;

        return this;
    }

    /// Convenience function in case fig isn't an lvalue.
    final void addFigure(Figure fig, uint row, uint col) {
        return addFigure(fig, row, col);
    }


    /**Draw the figure, but don't display it.*/
    void drawFigure() {
        if(zoomedFigure is null) {
            drawFigureZoomedOut();
        } else {
            drawFigureZoomedIn();
        }
    }

    /**Draw the plot to an explicit drawable, at the given size.  Note that
     * the depth must be 24 bits.*/
    void drawFigure(Drawable drawable, int width, int height) {
        // Save the default class-level values, make the values passed in the
        // class-level values, call drawPlot(), then restore the default values.
        auto oldDrawable = this.drawable;
        auto oldWidth = this._width;
        auto oldHeight = this._height;

        scope(exit) {
            this.drawable = oldDrawable;
            this._height = oldHeight;
            this._width = oldWidth;
        }

        this.drawable = drawable;
        this._width = width;
        this._height = height;
        drawFigure();
    }
}
}
